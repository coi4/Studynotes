# Java进阶

## 一、面对对象进阶

写程序的套路——设计对象处理数据解决问题

### 1、Static

#### 1.1、修饰成员变量

成员变量按照有无static修饰分为：

- 类变量：有static修饰，属于类，在计算机中只有一份，会**被类的全部对象共享**
  - 只需要通过类名就可以调用：类名 .静态变量
- 实例变量（对象的变量）：无static修饰，**属于每个对象**
  - 需要通过对象才能调用:对象 .实例变量

执行原理:

![image-20231117153055889](https://gitee.com/coi4/test/raw/master/img/image-20231117153055889.png)

![image-20231117153109221](https://gitee.com/coi4/test/raw/master/img/image-20231117153109221.png)

应用场景:如果某个数据只需要一份,且希望能被共享(访问、修改)，则该数据可以定义成类变量记住

访问自己类中中的类变量，可以省略类名不写，在某个类中访问其他类里的类变量，必须带类名访问

案例：系统启动后，要求用户可以记住自己创建了多少个用户对象![image-20231117153307023](https://gitee.com/coi4/test/raw/master/img/image-20231117153307023.png)

#### 1.2、修饰成员方法

分类：

- 类方法（静态方法）：有static修饰的，属于类
- 实例方法：无，属于对象

main方法：类方法![image-20231117153630549](https://gitee.com/coi4/test/raw/master/img/image-20231117153630549.png)

应用场景：做工具类（工具类中的方法都是类方法，每个方法都是用来完成一个功能，给开发人员共同使用的）（实例方法才需要创建对象调用，为了调用方法要创建对象——浪费内存）

工具类没有创建对象的需求，建议将工具类的构造器进行私有

注意事项：

- 类方法中可以直接访问类的成员，不可以直接访问实例成员
- 实例方法中可以出现this关键字，类方法中不可以

#### 1.3、代码块

类的5大成分之一（成员变量、构造器、方法、代码块、内部类）

分为：

- 静态代码块：
  - 格式：static{}
  - 特点：**类加载时自动执行**，由于类只会加载一次，所以静态代码块也只会执行一次
  - 作用：完成**类的初始化**（例如：对类变量的初始化赋值）
- 实例代码块：
  - 格式{}
  - 特点：每次创建对象时，执行实例代码块，并在**构造器前执行**
  - 作用：和构造器一样，都是用来完成**对象的初始化**（例如：对实例变量进行初始化赋值）

#### 1.4、单例设计模式

设计模式：具体问题最优解法方案（20多种）

重点：解决什么问题？怎么写？

单例设计模式：

- 确保一个类只有一个对象
- 写法：
  - 把类的构造器私有
  - 定义一个类变量记住类的一个对象
  - 定义一个类方法，返回对象
  - ![image-20231117154900565](https://gitee.com/coi4/test/raw/master/img/image-20231117154900565.png)
- 实现方式：
  - 饿汉式单例：拿对象时，对象早就创建好（如上图）
  - 懒汉式单例：拿对象时，才开始创建对象（用类的对象时才创建对象）（延迟加载对象）
    - 把类的构造器私有
    - 定义一个类变量用于存储对象
    - 提供一个类方法，保证返回的是同一个对象
    - ![image-20231122084332687](https://gitee.com/coi4/test/raw/master/img/image-20231122084332687.png)
- 好处：任务管理器对象，获取运行时对象；在这些业务场景下，使用单例模式，可以避免浪费内存

### 2、继承

三大特征之二

#### 2.1、快速入门

关键字：extends（让一个类和另一个类建立起父子关系）![image-20231122084637833](https://gitee.com/coi4/test/raw/master/img/image-20231122084637833.png)

特点：子类能继承父类的**非私有成员**（成员变量、成员方法）

继承后对象的创建：子类的对象是由子类、父类共同完成的

执行原理：子类对象实际是由子父类两张设计图共同创建出来的![image-20231122085048143](https://gitee.com/coi4/test/raw/master/img/image-20231122085048143.png)

![image-20231122085109628](https://gitee.com/coi4/test/raw/master/img/image-20231122085109628.png)

对象能直接访问什么成员，是由子父类这多张设计图共同决定的，这多张设计图对外暴露了什么成员，对象就可以访问什么成员

好处：减少重复代码的编写，提高代码复用性![image-20231122085359580](https://gitee.com/coi4/test/raw/master/img/image-20231122085359580.png)

#### 2.2、注意事项

声明不变，重新实现

- 权限修饰符：限制类中的成员（成员变量、方法、构造器、代码块.....）能被访问的范围
  - private：只能本类
  - 缺省：本类、同一个包中的类
  - protected：本类，同一个包中的类、子孙类中
  - public：任意位置
  - ![image-20231122085812436](https://gitee.com/coi4/test/raw/master/img/image-20231122085812436.png)
  - private<缺省<protected<public
- 单继承、object类：Java是**单继承**的，Java中的类不支持多继承，但是**支持多层继承**；
  - Object类：Java所有类的祖宗类
- 方法**重写**：当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，子类可以**重写一个方法名称、参数列表一样的方法**，覆盖父类的方法。
  - 重写后，方法的访问，Java会遵循就近原则
  - 使用Override注解，可以指定Java编译器，检查我们方法重写的格式是否正确，代码可读性也会更好
  - 子类重写父类方法，访问权限必须大于或等于父类该方法的权限
  - **重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小**
  - 私有方法、静态方法不能被重写，报错
  - 应用场景之一：子类重写Object类的toSpring（）方法（直接调用返回对象地址），以便返回对象的内容（属性值）
- 子类中访问其他成员的特点：就近原则
  - 先子类局部范围找，然后子类成员范围找，最后父类成员范围找，如果父类范围还没有找到则报错
  - 如果子父类中，出现了重名的成员，优先使用子类的，非要在子类中用父类的——super关键字，指定访问父类的成员：**super.父类成员变量/父类成员方法**
- 子类构造器的特点：子类的全部构造器，都会**先调用父类的构造器**，在执行自己
  - 子类如何调用父类构造器：默认情况下，子类全部构造器的第一行代码都是super（），会调用父类的无参构造器；**如果父类没有无参数构造器，必须在子类构造器第一行手写super（.....）**，指定去调用父类的有参数构造器
  - 应用场景：子类构造器可以通过调用父类构造器，把对象中包含父类这部分的先初始化赋值，再回来把对象里包含子类这部分的数据也进行初始化赋值（为父类这部分成员变量进行初始化赋值）![image-20231122092548905](https://gitee.com/coi4/test/raw/master/img/image-20231122092548905.png)
  - this（....）调用兄弟构造器：任意类的构造器中，可以通过this（...）去调用该类的其他构造器![image-20231122092839050](https://gitee.com/coi4/test/raw/master/img/image-20231122092839050.png)
    - this（...）、super（...）**都只能放在构造器的第一行**，因此有了this就不能写super，反之亦然。

this：代表本类对象的引用；super：代表父类存储空间的标识![image-20231122093127092](https://gitee.com/coi4/test/raw/master/img/image-20231122093127092.png)

### 3、多态

三大特征之三（封装、继承、多态）

多态是在继承/实现情况下的一种现象，表现为：**对象**多态、**行为**多态

![image-20231122093839994](https://gitee.com/coi4/test/raw/master/img/image-20231122093839994.png)

前提：有**继承/实现**关系；存在父类引用子类对象；存在**方法重写**

成员特点：

- 成员变量：编译运行**看左边**
- 成员方法：编译看左边，**运行看右边**（**调用的是重写后的方法**）

注意事项：Java中的属性（成员变量）不谈多态

好处：右边对象是解耦合的，便于扩展和维护（定义方法时，使用父类类型作为形参，可以接受一切子类对象，扩展性更强）

多态下不能使用子类的独有功能，解决方案：

- 类型转化（父类变量转换为子类类型）：

  - 自动类型转换（使用父类的功能就能完成相应的操作）（向下转型）：父类 变量名=new 子类![image-20231122094424657](https://gitee.com/coi4/test/raw/master/img/image-20231122094424657.png)

  - 强制类型转换（向上转型）：子类 变量名=（子类）父类变量![image-20231122094434683](https://gitee.com/coi4/test/raw/master/img/image-20231122094434683.png)

    ```
    //如果p接收的是子类对象
    if(父类 instance 子类){
    //将p转换为子类类型
    子类 变量名=（子类）父类变量 ；
    }
    ```

  - 注意事项：原本是什么类型，才能还原成什么类型

    - 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错

    - 运行时，发现对象的真实类型与强转后的类型不同，会报类型转换异常（ClassCastException）的错误![image-20231122094752134](https://gitee.com/coi4/test/raw/master/img/image-20231122094752134.png)

    - 强转前，建议使用instanceof关键字，判断当前对象的真是类型，再进行强转![image-20231122094849504](https://gitee.com/coi4/test/raw/master/img/image-20231122094849504.png)

      ```
    Fu f1=new Zi();
      Fu f2=new Son();
      if(f1 instanceof Zi){
         System.out.println("f1是Zi的类型")
      }
      ```

### 4、final

可以修饰类、方法、变量

修饰类：最终类——**不能被继承**了

修饰方法：最终方法——**不能被重写**了

修饰变量：**只能被赋值一次**

注意事项：

- 修饰基本类型的变量，变量存储的数据不能被改变
- 修饰**引用类型**的变量，变量存储的地址不能被改变，但地址所指向的对象的内容可以被改变

常量：使用了static final 修饰的成员变量；通常用于记录系统的配置信息

常量名的命名规范：建议使用大写字母；多个单词用下划线链接

程序编译后，常量会被宏替换：出现常量的地方全部会被替换成其记住的字面量，保证使用常量和直接用字面量的性能一样

![image-20231124141015743](https://gitee.com/coi4/test/raw/master/img/image-20231124141015743.png)

### 5、抽象类

abstract，修饰类，成员方法

修饰类——抽象类

修饰方法——抽象方法，**不能有方法体**

抽象类中不一定有抽象方法，**有抽象方法的类一定是抽象类**

主要特点：**抽象类不能创建对象**，仅作为一种特殊的父类，让子类继承并实现

一个类继承抽象类，**必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类**

场景和好处：多个类中只要有重复代码（包括相同的方法签名），我们都应该抽取到父类中，此时，父类中就有可能存在只有方法签名的方法，这时，父类必定是抽象类，抽出这样的抽象类，就是为了更好的支持多态；不知道系统未来具体业务实现时，可以先定义抽象类，让子类去继承实现，以便扩展

![image-20231124141747065](https://gitee.com/coi4/test/raw/master/img/image-20231124141747065.png)

常见应用场景：模板方法设计模式

- 解决方法中存在重复代码的问题
- 写法：
  - 定义一个抽象类
  - 在里面定义两个方法
    - **模板方法：把相同代码放里面去**
    - **抽象方法：具体实现交给子类完成**
- 建议用**final关键字修饰模板方法**
  - **模板方法给对象直接使用，不能被子类重写**
  - 一旦重写，方法失效

案例：

![image-20231124142222941](https://gitee.com/coi4/test/raw/master/img/image-20231124142222941.png)

- 定义一个抽象类
- 定义两个方法
- 定义子类继承抽象类，重写抽象方法
- 创建子类对象，调用模板方法完成功能

### 6、接口

interface，定义出一个特殊结构：接口

![image-20231124142447245](https://gitee.com/coi4/test/raw/master/img/image-20231124142447245.png)

接口是用来被类实现（implements）的，实现接口的类被称为实现类

![image-20231124142541479](https://gitee.com/coi4/test/raw/master/img/image-20231124142541479.png)

实现类**实现多个接口**，必须**重写**完全部接口的全部**抽象方法**，否则实现类需要定义成抽象类

好处：

- 弥补了类单继承的不足，类可以同时实现多个接口（通过接口，可以让一个类有一个亲爹的同时，还可以找多个干爹去扩展自己的功能）
- 通过接口去找干爹，别人通过你implements的接口，就可以显性的知道你是谁，从而也就可以放心地把你当作谁来用

- 让程序可以面向接口编程，这样既不用关心实现的细节，也可以灵活方便的切换各种实现

案例：

班级学生信息管理模块的开发

![image-20231124143444709](https://gitee.com/coi4/test/raw/master/img/image-20231124143444709.png)

jdk8后接口新增三种形式的方法：

![image-20231124143526362](https://gitee.com/coi4/test/raw/master/img/image-20231124143526362.png)

- 默认方法：使用default修饰，使用**实现类的对象调用**
- 静态方法：static修饰，必须用**当前接口名调用**
- 私有方法：private修饰，只能在接口内部被调用
- 默认被public修饰

便于扩展与维护

接口的多继承：一个接口可以同时继承多个接口，便于实现类去实现![image-20231124143839686](https://gitee.com/coi4/test/raw/master/img/image-20231124143839686.png)

注意事项：

- 一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承
- 一个类实现多个接口，如果多个接口中存在方法签名冲突，此时不支持多实现
- 一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会**优先用父类的**
- 一个类实现了多个接口，多个接口中存在同名的默认方法；可以不冲突，这个类重写该方法即可

### 7、内部类

内部类：类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），**如果一个类定义在另一个类内部，这个类就成为内部类**

场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类

#### 7.1、成员内部类

类中的一个普通成员；JDK16之前，成员内部类中不能定义静态成员，后可以

格式：![image-20231201142351690](https://gitee.com/coi4/test/raw/master/img/image-20231201142351690.png)

成员内部类中访问其他成员特点：

- 可以直接访问外部类的实例成员、静态成员
- 可以拿到当前外部类对象，格式是：`外部类名.this`

#### 7.2、静态内部类

有static修饰的内部类，属于**外部类自己特有**

格式：![image-20231201142647050](https://gitee.com/coi4/test/raw/master/img/image-20231201142647050.png)

可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员

#### 7.3、局部内部类

定义在方法中、代码块中、构造器等执行体中，很鸡肋！

#### 7.4、*匿名内部类

特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字

格式：![image-20231201142934003](https://gitee.com/coi4/test/raw/master/img/image-20231201142934003.png)

本质就是一个子类，并会立即创建出一个子类对象

用于更方便的创建一个子类对象

场景：

- 通常作为一个参数传输给方法：![image-20231201143143981](https://gitee.com/coi4/test/raw/master/img/image-20231201143143981.png)

  ![image-20231201143154396](https://gitee.com/coi4/test/raw/master/img/image-20231201143154396.png)

### 8、枚举

特殊类

格式：![image-20231208144213534](https://gitee.com/coi4/test/raw/master/img/image-20231208144213534.png)

注意：

- 第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开；
- 这些名称，本质上是常量，**每一个常量都会记住枚举类的一个对象**；
- 构造器都是私有的，对外不能创建对象
- **都是最终类，不可以被继承**
- 从第二行开始，可以定义类的其他各种成员
- 枚举类都是继承java.lang.Enum类的，从enum类也会继承到一些方法

使用枚举类实现单例设计模式

应用场景：

- 用来表示一组信息，然后作为参数进行传输（选择定义一个一个变量表示一组信息，并作为参数传输）
- 参数值不受约束（定义枚举表示一组信息，并作为参数传输）
- 代码可读性好，参数值得到了约束，对使用者更友好

### 9、泛型

定义类，接口、方法时，同时声明了一个或者多个类型变量（如：`<E>`)，称为泛型类，泛型接口、泛型方法、统称泛型

![image-20231208150857021](https://gitee.com/coi4/test/raw/master/img/image-20231208150857021.png)

作用：提供了编译阶段约束所能操作的数据类型，并自动进行检查的能力，避免强制类型转换

本质：把具体的数据类型作为参数传给类型变量

泛型类：

- ![image-20231208151023491](https://gitee.com/coi4/test/raw/master/img/image-20231208151023491.png)

泛型接口：

- ![image-20231208151047038](https://gitee.com/coi4/test/raw/master/img/image-20231208151047038.png)

泛型方法：

- ![image-20231208151122331](https://gitee.com/coi4/test/raw/master/img/image-20231208151122331.png)
- ![image-20231208151151860](https://gitee.com/coi4/test/raw/master/img/image-20231208151151860.png)
- 通配符：？，可以在”使用泛型“时代表一切类型
- 泛型上下限
  - 上限：？extends Car：？能接收的必须是Car或其子类
  - 下限：？ super Car：？能接收的必须是Car或其父类

注意事项：

- 一旦程序编译成class文件，class文件中就不存在泛型（泛型擦除）
- **不支持基本数据类型**，只支持对象 类型（引用数据类型）

## 二、常用API

应用程序编程接口

### 1、API（一）

#### 1.1、Object类

祖宗类

| 方法                              |                                      |
| --------------------------------- | ------------------------------------ |
| public String toString（）        | 返回对象的字符串表示                 |
| public boolean equals（Object o） | 判断两个对象是否相等                 |
| protected Object clone（）        | 对象克隆（返回一个一摸一样的新对象） |

toString（）方法存在的意义就是为了被子类重写，以便返回对象具体内容

equals存在的意义：被子类重写，以便子类自己来定制比较规则（比如比较对象内容）（直接比较两个对象的地址是否相同完全可以用==）

浅克隆：数据一模一样（引用类型拷贝的只是地址）

深克隆：对象中基本类型的数据直接拷贝；字符串拷贝的还是地址；对象中还包含其他对象，不会拷贝地址，会创建新对象（数组）

#### 1.2、Objects

工具类，提供了很多操作对象的静态方法

Objects.equals(s1,s2)；

| 方法                                               |                              |
| -------------------------------------------------- | ---------------------------- |
| public static boolean equals（Object a，Object b） | 先做非空判断，再比较两个对象 |
| public static boolean isNull（Object obj）         | 判断是否非空，空返回true     |
| public static boolean nonNull（Object obj）        | 判断是否不为null             |

![image-20231208153450896](https://gitee.com/coi4/test/raw/master/img/image-20231208153450896.png)

#### 1.3、包装类

把基本数据类型包装成对象

![image-20231208154031501](https://gitee.com/coi4/test/raw/master/img/image-20231208154031501.png)

![image-20231208154103615](https://gitee.com/coi4/test/raw/master/img/image-20231208154103615.png)

自动装箱：基本数据类型可以自动转换为包装类型

自动拆箱

可以把基本类型的数据转换成字符串类型：![image-20231208154217051](https://gitee.com/coi4/test/raw/master/img/image-20231208154217051.png)

String rs1=Integer.toString(23);

可以把字符串类型的数值转换成数值本身对应的数据类型：![image-20231208154302594](https://gitee.com/coi4/test/raw/master/img/image-20231208154302594.png)

#### 1.4、StringBuilder、StringBuffer

StringBuilder代表可变字符串对象，相当于一个容器，装的字符串可以改变，操作字符串的；比String更适合修改字符串（String是不可变字符串，频繁操作，产生很多无用对象）

| 构造器                              |                                        |
| ----------------------------------- | -------------------------------------- |
| public StringBuileder（）           |                                        |
| public StringBuileder（String str） | 创建一个指定字符串内容的可变字符串对象 |

| 方法                                    |                                     |
| --------------------------------------- | ----------------------------------- |
| public StringBuilder append（任意类型） | 添加数据并返回StringBuilder对象本身 |
| StringBuilder reverse（）               | 将对象内容反转                      |
| int length（）                          | 返回对象内容长度                    |
| String toString（）                     | 通过toString可以实现转化为String    |

如果操作字符串较少，或者不需要操作，以及定义字符串变量，建议用String

StringBuffer的用法与StringBuilder一模一样；StringBuilder线程不安全，StringBuffer线程安全

案例：

需求：设计一个方法，用于返回任意整型数组的内容，要求返回的数组内容格式如：[11,22,33]

- 需要接收数据
- 需要返回拼接后字符串
- 方法内部：遍历，把遍历到的数据都拼接起来，用StringBuilder来完成

#### 1.5、StringJoiner

JDK8开始才有，能提高字符串操作效率

| 构造器                                              |                                                |
| --------------------------------------------------- | ---------------------------------------------- |
| public StringJoiner（间隔符号）                     | 创建一个StringJoiner对象，指定拼接时的间隔符号 |
| public StringJoiner（间隔符号，开始符号，结束符号） | 指定拼接时的间隔符号，开始符号，结束符号       |

| 方法                         |                              |
| ---------------------------- | ---------------------------- |
| StringJoiner add（添加内容） | 添加数据并返回对象本身       |
| int length（）               | 返回字符出现个数             |
| String toString（）          | 返回字符串（拼接之后的结果） |

### 2、API（二）

#### 2.1、Math、System、Runtime

Math：工具类，提供对数据进行操作的一些静态方法

| 方法                             |                                        |
| -------------------------------- | -------------------------------------- |
| int abs（int a）                 | 获取参数绝对值                         |
| double ceil（double a）          | 向上取整                               |
| double floor（double a）         | 向下取整                               |
| int round（float a）             | 四舍五入                               |
| int max（int a，int b）          | 取较大值                               |
| double pow（double a，double b） | 返回a的b次幂的值                       |
| double random（）                | 返回值为double的随机值，范围[0.0，1.0] |

System：工具类，代表程序所在的系统

| 方法                       |                              |
| -------------------------- | ---------------------------- |
| void exit（int status）    | 当前运行的Java虚拟机终止     |
| long currentTimeMillis（） | 返回当前系统的时间毫秒值形式 |

> 时间毫秒值：1970年1月1日 00：00：00到现在的总毫秒数（1s=1000ms）

Runtime：单例类，代表程序所在的运行环境

| 方法                           |                                        |
| ------------------------------ | -------------------------------------- |
| Runtime getRuntime（）         | 返回与当前Java应用程序关联的运行时对象 |
| void exit（int status）        | 终止                                   |
| int availableProcessors（）    | 返回Java虚拟机可用的处理器数           |
| long totalMemory（）           | 内存总量                               |
| long freeMemory（）            | 可用内存                               |
| Process exec（String command） | 启动某个程序，并返回该程序的对象       |

#### 2.2、BigDecimal

用于解决浮点型运算时，出现失真问题（浮点型运算时，直接+ - * /可能会出现结果失真问题）

![image-20231213091928611](https://gitee.com/coi4/test/raw/master/img/image-20231213091928611.png)

| 构造器                          |                                    |
| ------------------------------- | ---------------------------------- |
| public BigDecimal（double val） | 将double转换为BigDecimal（不推荐） |
| public BigDecimal（String val） | 把String转成Bigdecimal             |

| 方法                                                         |                              |
| ------------------------------------------------------------ | ---------------------------- |
| BigDecimal valuefOf（double val）                            | 转换一个double成BigDecimal   |
| BigDecimal add（BigDecimal b）                               | 加法                         |
| BigDecimal subtract（BigDecimal b）                          | 减法                         |
| BigDecimal multiply（BigDecimal b）                          | 乘法                         |
| BigDecimal divide（BigDecimal b）                            | 除法                         |
| BigDecimal divide（另一个BigDecimal对象，精确几位，舍入模式） | 除法，可以控制精确到小数几位 |
| double doublevalue（）                                       | 将BigDecimal转换为double     |

`BigDecimal b1=BigDecimal.valueOf(0.1)`

#### 2.3、JDK8之前的传统日期、时间

Data：日期时间

| 构造器            |                                            |
| ----------------- | ------------------------------------------ |
| Data（）          | 创建一个Data对象，代表系统当前此刻日期时间 |
| Data（long time） | 把时间毫秒值转换成Data日期对象             |

| 方法                      |                                              |
| ------------------------- | -------------------------------------------- |
| long getTime（）          | 返回从1970年1月1日到此刻的总毫秒值           |
| void setTime（long time） | 设置日期对象的时间为当前时间毫秒值对应的时间 |

![image-20231213093349777](https://gitee.com/coi4/test/raw/master/img/image-20231213093349777.png)

SimpleDataFormat：把日期对象、时间毫秒值格式化成我们想要的形式

| 构造器                            |                                        |
| --------------------------------- | -------------------------------------- |
| SimleDataFormat（String pattern） | 创建简单日期格式对象，并封装时间的格式 |

| 方法                          |                                   |
| ----------------------------- | --------------------------------- |
| String  format（Data data）   | 将日期格式化成日期/时间字符串     |
| String  format（Object time） | 将时间毫秒值式化成日期/时间字符串 |

![image-20231213093843136](https://gitee.com/coi4/test/raw/master/img/image-20231213093843136.png)

解析字符串时间成为日期对象：`public Data parse(String source)`

需求:小贾下单并付款的时间为:2023年11月11日 00：01：18；小皮下单并付款的时间为:2023年11月11日 00：10：51；请用代码说明这两位同学有没有参加上秒杀活动![image-20231213094245977](https://gitee.com/coi4/test/raw/master/img/image-20231213094245977.png)

Calendar：代表系统此刻时间对应的日历；可以单独获取、修改事件中的年、月、日、时、分、秒等

| 方法                              |                             |
| --------------------------------- | --------------------------- |
| Calendar getInstance（）          | 获取当前日历对象            |
| int get（int field）              | 获取日历中某个信息          |
| Data getTime（）                  | 获取日期对象                |
| long getTimeMillis（）            | 获取时间毫秒值              |
| set（int field，int value）       | 修改日历中某个信息          |
| void add（int field，int amount） | 为某个信息增加/减少指定的值 |

#### 2.4、JDK8开始新增的日期、时间

LocalDate：年、月、日

LocalTime：时、分、秒

LocalDateTime：年、月、日、时、分、秒

ZoneId:时区

ZoneDateTime:带时区的时间

获取对象方法：

| 方法名                                     | 示例                                          |
| ------------------------------------------ | --------------------------------------------- |
| Xxxx now（）：获取系统当前时间对应的该对象 | LocalDate  Id=LocalDate.now();                |
| Xxxx of（...）：获取指定时间的对象         | Localdate localDate1=LocalDate.of(2099,11,11) |

LocalDate常用API

| 方法名                   |                                       |
| ------------------------ | ------------------------------------- |
| int geYear()             | 获取年                                |
| int getMonthValue()      | 获取月份                              |
| int getDayOfMonth()      | 获取日                                |
| int getDayOfYear()       | 获取当前是一年中的第几年              |
| DayOfWeek getDayOfWeek() | 获取星期几:Id.getDayOfWeek().getValue |

![image-20231214164856570](https://gitee.com/coi4/test/raw/master/img/image-20231214164856570.png)

LocalTime

![image-20231214164940299](https://gitee.com/coi4/test/raw/master/img/image-20231214164940299.png)

![image-20231214165004378](https://gitee.com/coi4/test/raw/master/img/image-20231214165004378.png)

LocalDateTime

![image-20231214165139613](https://gitee.com/coi4/test/raw/master/img/image-20231214165139613.png)

LocalDateTime转换成LocalDate、LocalTime

![image-20231214165257940](https://gitee.com/coi4/test/raw/master/img/image-20231214165257940.png)

ZoneId

![image-20231214165402030](https://gitee.com/coi4/test/raw/master/img/image-20231214165402030.png)

ZoneDateTime

![image-20231214165428310](https://gitee.com/coi4/test/raw/master/img/image-20231214165428310.png)

Instant：时间戳/时间线（代替Date）；可用于记录代码的执行时间、或记录用户操作某个时间的时间点；可精确到纳秒，不可变对象

![image-20231214165758886](https://gitee.com/coi4/test/raw/master/img/image-20231214165758886.png)

DateTimeformatter：用于时间的格式化和解析

![image-20231214165811714](https://gitee.com/coi4/test/raw/master/img/image-20231214165811714.png)

Duration：时间间隔（时、分、秒、纳秒）；可用于计算两个事件对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant

![image-20231214170043594](https://gitee.com/coi4/test/raw/master/img/image-20231214170043594.png)

Period：时间间隔（年、月、日）；可用于计算两个LocalDate对象相差的年数、月数

![image-20231214165907679](https://gitee.com/coi4/test/raw/master/img/image-20231214165907679.png)

#### 2.5、Arrays

操作数组的工具类

![image-20231214170112690](https://gitee.com/coi4/test/raw/master/img/image-20231214170112690.png)

![image-20231214170133832](https://gitee.com/coi4/test/raw/master/img/image-20231214170133832.png)

给对象排序：实现Comparable接口

自定义排序规则

- 认为左边对象大于右边对象：返回正整数
- 认为左边对象小于右边，返回负整数
- 认为左边对象等于右边对象，返回0整数

#### 2.6、JDK8新特性：Lambda表达式

用于简化匿名内部类的代码写法（只能简化函数式接口的匿名内部类）

![image-20231214170439480](https://gitee.com/coi4/test/raw/master/img/image-20231214170439480.png)

函数式接口：

- 有且仅有一个抽象方法的接口
- 有@Functionallnterface注释的

![image-20231214170633878](https://gitee.com/coi4/test/raw/master/img/image-20231214170633878.png)

省略写法：

- 参数类型可以省略不写
- 如果只有一个参数，参数类型可以省略，同时（）也可以省略
- 如果方法体代码只有一行代码，可以省略大括号，同时省略分号，如果这行代码是return语句，也必须去掉return不写

#### 2.7、新特性：方法引用

静态方法引用：

- 类名：：静态方法

- 使用场景：如果某个Lambda表达式里只是调用一个静态方法，并且前后参数的形式一致，就可以使用静态方法引用

实例方法引用

- 对象名：：实例方法
- 场景：表达式里只是调用一个实例方法，并且前后参数的形式一致，就可以使用实例方法引用

特定类型方法引用

- 类型：：方法
- 场景：只是调用一个实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用

构造器引用

- 类名：：new
- 只是在创建对象，并且前后参数情况一致

### 3、API（三）

#### 3.1、常见算法

#### 3.2、正则表达式

有一些特定的字符组成，代表的是一个规则

用来校验数据格式是否合法；在一段文本中查找满足要求的内容

String提供了一个匹配正则表达式的方法：`public boolean matches(String regex)`判断字符串是否匹配正则表达式,匹配返回true

regex(正则表达式)书写规则：![屏幕截图 2023-12-13 081614](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-13%20081614.png)

预定义字符（只匹配单个字符）

![屏幕截图 2023-12-13 081639](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-13%20081639.png)

数量词

![image-20231213081742660](https://gitee.com/coi4/test/raw/master/img/image-20231213081742660.png)

![image-20231213081858576](https://gitee.com/coi4/test/raw/master/img/image-20231213081858576.png)

![image-20231213081909501](https://gitee.com/coi4/test/raw/master/img/image-20231213081909501.png)

案例：

需求：校验用户输入的电话、邮箱、时间是否合法

用于查找信息：

需求：请把下面文本中的电话，邮箱，座机号码，热线都爬取出来![image-20231213082049400](https://gitee.com/coi4/test/raw/master/img/image-20231213082049400.png)

![image-20231213082106237](https://gitee.com/coi4/test/raw/master/img/image-20231213082106237.png)

需求：只需要把每个邮箱中的用户名爬取出来

需求：某系统的日志文件记录了当天进入系统的全部用户信息，需要把这些用户的名字爬取出来另作他用

![image-20231213083205119](https://gitee.com/coi4/test/raw/master/img/image-20231213083205119.png)

![image-20231213083214353](https://gitee.com/coi4/test/raw/master/img/image-20231213083214353.png)



用于搜索替换、分割内容：

| 方法                                                    |                                                            |
| ------------------------------------------------------- | ---------------------------------------------------------- |
| public string replaceAll（string regex，string newstr） | 按照正则表达式匹配的内容进行替换                           |
| public string[] split（string regex）                   | 按照正则表达式匹配的内容进行分割字符串，返回一个字符串数组 |



#### 3.3、异常

##### 3.3.1、认识异常

![image-20231201151346117](https://gitee.com/coi4/test/raw/master/img/image-20231201151346117.png)



> error：系统级别错误（严重错误），表示系统出现问题，sun公司自己用
>
> Exception：叫异常，代表程序异常，程序员通常会用Exception以及它的孩子来封装程序出现的问题
>
> - 运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（比如：数组索引越界异常）
> - 编译时异常：编译阶段就会出现错误提醒（比如：日期解析异常）

抛出异常（throws）

- 在方法上使用throws关键字，可以将方法内部出现的异常跑出去给调用者处理![image-20231201151839508](https://gitee.com/coi4/test/raw/master/img/image-20231201151839508.png)

捕获异常（try...catch)：

- 直接捕获程序出现的异常![image-20231201151937657](https://gitee.com/coi4/test/raw/master/img/image-20231201151937657.png)

用来查找bug；可以作为方法内部的特殊返回值，通知上层调用者底层的执行情况

##### 3.3.2、自定义异常

企业自己的某种问题，想通过异常来表示，以便用异常来管理该问题，就需要自己来定义异常类

种类：

- 自定义运行时异常：![image-20231201152405530](https://gitee.com/coi4/test/raw/master/img/image-20231201152405530.png)
- 自定义编译时异常：![image-20231201152413302](https://gitee.com/coi4/test/raw/master/img/image-20231201152413302.png)

异常有什么作用：

1. 用来查询系统Bug的关键参考信息
2. 可以作为方法内部的一种特殊返回值，以便通知上层调用者底层的执行情况

##### 3.3.3、异常的处理

捕获异常，记录异常并响应合适的信息给用户

捕获异常，尝试重新修复

**底层的异常抛出去给最外层，最外层集中捕获处理**

抛出异常（throws）

- 在方法上使用throws关键字，可以将方法内部出现的异常跑出去给调用者处理![image-20231201152844738](https://gitee.com/coi4/test/raw/master/img/image-20231201152844738.png)

捕获异常（try...catch）

- 直接捕获程序出现的异常![image-20231201152941489](https://gitee.com/coi4/test/raw/master/img/image-20231201152941489.png)

### 3、集合(java.util)

一种容器，用来装数据，类似数组，大小可变

![image-20231219120314260](https://gitee.com/coi4/test/raw/master/img/image-20231219120314260.png)

#### 3.1、collection集合

![image-20231219120337562](https://gitee.com/coi4/test/raw/master/img/image-20231219120337562.png)

List：有序、可重复、有索引

Set：无序、不重复、无索引

- HashSet：无序、不重复、无索引
- LinkedHashSet：有序、不重复、无索引
- TreeSet：按照大小默认升序、不重复、无索引

##### 3.1.1、常用方法

![image-20231219120712456](https://gitee.com/coi4/test/raw/master/img/image-20231219120712456.png)

##### 3.1.2、遍历方式

迭代器：专用方式（数组没有）

![image-20231219120823857](https://gitee.com/coi4/test/raw/master/img/image-20231219120823857.png)

![image-20231219120843658](https://gitee.com/coi4/test/raw/master/img/image-20231219120843658.png)

![image-20231219120930915](https://gitee.com/coi4/test/raw/master/img/image-20231219120930915.png)

越界：出现NoSuchElementEception异常

增强for：遍历集合或数组；修改变量值不会影响到集合中的元素

- ![image-20231219121032906](https://gitee.com/coi4/test/raw/master/img/image-20231219121032906.png)

  ![image-20231219121045782](https://gitee.com/coi4/test/raw/master/img/image-20231219121045782.png)

  ![image-20231219121209612](https://gitee.com/coi4/test/raw/master/img/image-20231219121209612.png)

lambda表达式：更简单、更直接

- ![image-20231219121241957](https://gitee.com/coi4/test/raw/master/img/image-20231219121241957.png)

  ![image-20231219121258536](https://gitee.com/coi4/test/raw/master/img/image-20231219121258536.png)

  ![image-20231219121310030](https://gitee.com/coi4/test/raw/master/img/image-20231219121310030.png)

案例：遍历集合中的自定义对象

需求：展示多部电影信息

![image-20231219121418889](https://gitee.com/coi4/test/raw/master/img/image-20231219121418889.png)

![image-20231219121442625](https://gitee.com/coi4/test/raw/master/img/image-20231219121442625.png)

##### 3.1.3、List集合

特有方法：![image-20231219121536079](https://gitee.com/coi4/test/raw/master/img/image-20231219121536079.png)

遍历方式：增强for

底层原理

- ArrayList：基于数组实现——查询快，删除效率低，添加效率极低（存满扩容1.5倍，1.5倍后以实际为准）
  - 适合根据索引查询数据，数据量不是很大；不适合数据量大，频繁增删
- Linkedist：基于双链表实现（链表中的结点是独立的对象，在内存中不连续，每个结点包含数据值和下一个结点的地址）——单向链表（查询慢（从头查）、增删相对快））双向链表（查询慢、增删相对较快，但对首尾元素进行增删改查的速度极快）![image-20231219122259946](https://gitee.com/coi4/test/raw/master/img/image-20231219122259946.png)
- LinkedList可以用来设计队列（先进先出）

##### 3.1.4、Set集合

哈希值：int类型数值，Java中每个对象都有一个哈希值

Java中的所有对象都可以调用Object类提供的hashCode方法，返回哈希值

哈希值特点：

- 同一个对象多次调用hashCode（）方法返回的哈希值是相同的
- 不同对象，哈希值一般不同，但也有可能会相同（哈希值碰撞）

底层原理

- HashSet：基于哈希表实现——增删改查性能都很好的数据结构，
  - JDK8之前，哈希表=数组+链表
  - JDK开始，哈希值=数组+链表+红黑树（链表长度超过8，数组长度>=64，自动将链表转成红黑树）
  - ![image-20231219122914000](https://gitee.com/coi4/test/raw/master/img/image-20231219122914000.png)
  - 去重复机制：重写对象的hashCode（）和equals（）![image-20231219123314588](https://gitee.com/coi4/test/raw/master/img/image-20231219123314588.png)
- LinkedHashSet：哈希表+每一元素都额外多了一个双链表机制记录前后元素位置

TreeSet集合：红黑树

- 数值类型，Integer，Double默认按照数值本身大小排序
- 字符串类型：首字母
- 自定义对象，无法直接排
  - 自定义排序规则
    - 方式一：自定义类实现Comparable接口，**重写compareTo**
    - 二：调用TreeSet集合有参数构造器，**设置Comparator对象**（比较器对象，指定比较规则）
    - 默认使用集合自带的比较器

##### 3.1.5、集合的并发修改异常

使用遍历同时删除集合中的数据

解决：

- 迭代器遍历，用迭代器自己的删除方法删除数据
- for，倒着遍历并删除；从前往后遍历，删除元素后i--

#### 3.2、map集合

* 双列集合，也叫键值对集合
* 每个元素“ key=value” 称为一个键值对 / 键值对对象 / 一个 Entry 对象
* 所有**键是不允许重复**的，但值可以重复
* 运用场景：**需要存储一一对应数据时**，可以考虑

##### 3.2.1.、map常用方法

| 方法名                       | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| .put(K key,V value)          | **添加**元素(map.put("手表"，100))                           |
| .size()                      | 获取集合**大小**                                             |
| .clear()                     | **清空**集合                                                 |
| .isEmpty()                   | 判断集合**是否为空**，为空返回 true , 反之                   |
| .get(Object key)             | 根据键**获取对应值**（map.get("手表")                        |
| .remove(Object key)          | 根据键**删除整个元素**( 返回键的值)(map.remove( "手表 "))    |
| .containsKey(Object key)     | 判断**是否包含某个键**(返回ture/false)                       |
| .containsValue(Object value) | 判断**是否包含某个值**(map.containsValue(100))               |
| Set<K> keySet()              | **获取全部键**的集合(Set<String> keys=map.keySet();)         |
| Collection<V> values()       | **获取**Map集合的**全部值**(Collection<Integer) values=map.values();) |
| .pulAll(Object)              | 把其他集合数据**倒入**自己集合中(map1.putAll(map2);)(map2集合倒入map1) |

##### 3.2.2、遍历方法

* 键找值

  ```java
  // 1、获取全部键
  Set<String> keys=map.keySet();
  
  // 2、遍历全部键，根据键获取对应值
  for(String key:keys){
      double value=map.get(key);
            System.out.println(key+"====>"+value);
  }
  
  ```

* 键值对（难度较大）

  ```java
  // 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合
  Set<Map.Entry<String,Double>> entries=map.entrySet();
  
  for(Map.Entry<String,Double>entry:entries){
      String key=entry.getKey();
      double value=entry.getValue();
      System.out.println(key+"====>"+value);
  }
  ```

  

* **Lambda**（JDK8之后）（非常简单）

  ```java
  //遍历map集合，传递Lambda表达式
  map.forEach((k,v)->{
      System.out.println(k+"---->"+v);
  });
  ```


##### 3.2.3、HashMap

* 用的最多

* 无序、不重复（后面重复的数据（值）会覆盖前面的数据）、无索引

* 跟HashSet底层原理一样，基于哈希表实现（原来学的 Set 系列集合的底层就是基于 Map 实现的，只是 Set 集合中的元素只要键数据，不要值数据）（增删改查的性能都较好）

* **利用键计算哈希值**，与值无关

* 依赖 **hashCode** 方法和 **equals** 方法保证键的唯一

* 如果键要存储的是自定义对象，需要重写 hashCode 和 equals 方法

* ```java
  Map<String, Integer> map = new HashMap<>() ;
  ```


##### 3.2.4、LinkedHashMap

* 有序（存储和取出顺序一样）、不重复、无索引

* 底层原理跟LinkedHashSet一样为哈希表+双链表（保证有序）

* ```java
  Map<String, Integer> map = new LinkedHashMap<>();
  ```

##### 3.2.5、TreeMap

* **按照键**大小默认升序排序、不重复、无索引

* 跟TreeSet一样基于红黑树实现

* 同样支持两种方式指定排序顺序

* ```java
  //第一步：先让Student类，实现Comparable接口
  public class Student implements Comparable<Student>{
      private String name;
      private int age;
      private double height;
  	//无参数构造方法
      public Student(){}
      //全参数构造方法
      public Student(String name, int age, double height){
          this.name=name;
          this.age=age;
          this.height=height;
      }
      //...get、set、toString()方法自己补上..
      
      //按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。
      /*
      原理：
      在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的
      结果是正数、负数、还是零，决定元素放在后面、前面还是不存。
      */
      @Override
      public int compareTo(Student o) {
          //this：表示将要添加进去的Student对象
          //o: 表示集合中已有的Student对象
          return this.age-o.age;
      }
  }
  
  ```

* ```java
  /**
   * 目标：掌握TreeMap集合的使用。
   */
  public class Test3TreeMap {
      public static void main(String[] args) {
          Map<Student, String> map = new TreeMap<>(new Comparator<Student>() {
              @Override
              public int compare(Student o1, Student o2) {
                  return Double.compare(o1.getHeight(), o2.getHeight());
              }
          });
  //        Map<Student, String> map = new TreeMap<>(( o1,  o2) ->   Double.compare(o2.getHeight(), o1.getHeight()));
          map.put(new Student("蜘蛛精", 25, 168.5), "盘丝洞");
          map.put(new Student("蜘蛛精", 25, 168.5), "水帘洞");
          map.put(new Student("至尊宝", 23, 163.5), "水帘洞");
          map.put(new Student("牛魔王", 28, 183.5), "牛头山");
          System.out.println(map);
      }
  }
  ```


##### 3.2.6、案例合集

1. 统计投票人数

   > 某个班级 80 名学生，现在需要组织秋游活动，班长提供了四个景点依次是（ A 、 B 、 C 、 D ） ,
   > 每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。

   ```java
   // 1、把80个学生选择的景点数据拿到程序中来。
           List<String> data = new ArrayList<>();
           String[] selects = {"A", "B", "C", "D"};
           Random r = new Random();
           for (int i = 1; i <= 80; i++) {
               // 每次模拟一个学生选择一个景点，存入到集合中去。
               int index = r.nextInt(4); // 0 1 2 3
               data.add(selects[index]);
           }
           System.out.println(data);
   
           // 2、开始统计每个景点的投票人数
           // 准备一个Map集合用于统计最终的结果
           Map<String, Integer> result = new HashMap<>();
   
           // 3、开始遍历80个景点数据
           for (String s : data) {
               // 问问Map集合中是否存在该景点
               if(result.containsKey(s)){
                   // 说明这个景点之前统计过。其值+1. 存入到Map集合中去
                   result.put(s, result.get(s) + 1);
               }else {
                   // 说明这个景点是第一次统计，存入"景点=1"
                   result.put(s, 1);
               }
           }
           System.out.println(result);
       }
   }
   
   ```

2. HashMap集合存储自定义对象并遍历

   > 创建一个HashMap集合，键是学生对象（Student），值是籍贯（String），存储三个键值对元素，并遍历

   ```java
   public class Student implements Comparable<Student> {
       private String name;
       private int age;
       private double height;
   
       // this  o
       @Override
       public int compareTo(Student o) {
           return this.age - o.age; // 年龄升序排序
       }
   
       @Override
       public boolean equals(Object o) {
           if (this == o) return true;
           if (o == null || getClass() != o.getClass()) return false;
           Student student = (Student) o;
           return age == student.age && Double.compare(student.height, height) == 0 && Objects.equals(name, student.name);
       }
   
       @Override
       public int hashCode() {
           return Objects.hash(name, age, height);
       }
   
       public Student() {
       }
   
       public Student(String name, int age, double height) {
           this.name = name;
           this.age = age;
           this.height = height;
       }
   
   	//...get,set方法自己补全....
   
       @Override
       public String toString() {
           return "Student{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   ", height=" + height +
                   '}';
       }
   }
   ```

   ```java
   /**
    * 目标：掌握Map集合下的实现类：HashMap集合的底层原理。
    */
   public class Test1HashMap {
       public static void main(String[] args) {
           Map<Student, String> map = new HashMap<>();
           map.put(new Student("蜘蛛精", 25, 168.5), "盘丝洞");
           map.put(new Student("蜘蛛精", 25, 168.5), "水帘洞");
           map.put(new Student("至尊宝", 23, 163.5), "水帘洞");
           map.put(new Student("牛魔王", 28, 183.5), "牛头山");
           System.out.println(map);
       }
   }
   
   ```

3. TreeMap练习

   > 创建一个TreeMap集合，键是学生对象（Student），值是籍贯（String）。学生属性姓名和年龄，按照年龄进行排序并遍历

4. 集合嵌套

   > 

```java
/**
 * 目标：理解集合的嵌套。
 * 江苏省 = "南京市","扬州市","苏州市“,"无锡市","常州市"
 * 湖北省 = "武汉市","孝感市","十堰市","宜昌市","鄂州市"
 * 河北省 = "石家庄市","唐山市", "邢台市", "保定市", "张家口市"
 */
public class Test {
    public static void main(String[] args) {
        // 1、定义一个Map集合存储全部的省份信息，和其对应的城市信息。
        Map<String, List<String>> map = new HashMap<>();

        List<String> cities1 = new ArrayList<>();
        Collections.addAll(cities1, "南京市","扬州市","苏州市" ,"无锡市","常州市");
        map.put("江苏省", cities1);

        List<String> cities2 = new ArrayList<>();
        Collections.addAll(cities2, "武汉市","孝感市","十堰市","宜昌市","鄂州市");
        map.put("湖北省", cities2);

        List<String> cities3 = new ArrayList<>();
        Collections.addAll(cities3, "石家庄市","唐山市", "邢台市", "保定市", "张家口市");
        map.put("河北省", cities3);
        System.out.println(map);

        List<String> cities = map.get("湖北省");
        for (String city : cities) {
            System.out.println(city);
        }

        map.forEach((p, c) -> {
            System.out.println(p + "----->" + c);
        });
    }
}

```

#### 3.3、Stream流

简化集合、数组操作的 API 。结合了 Lambda 表达式

* 先**得到**集合或者数组的 Stream 流。
* 然后**调用** Stream 流的**方法**对数据进行处理。
* **获取**处理的**结果**。

示例：

> 有一个List集合，元素有"张三丰","张无忌","周芷若","赵敏","张强"，找出姓张，且是3个字的名字，存入到一个新集合中去。

```java
// 找出姓张，且是3个字的名字，存入到一个新集合中去。
List<String> list = new ArrayList<>();
for (String name : names) {
    if(name.startsWith("张") && name.length() == 3){
        list.add(name);
    }
}
System.out.println(list);

```

```java
List<String> list2 = names.stream().filter(s -> s.startsWith("张")).filter(a -> a.length()==3).collect(Collectors.toList());
System.out.println(list2);

```

##### 3.3.1、Stream流常用方法

###### 3.3.1.1、获取Stream流

- 获取集合的

  - List集合的

    - Stream<E> stream()

    - > 找出姓张，且是3个字的名字，存入到一个新的集合

    - ```java
      List<String> names = new ArrayList<>();
              Collections.addAll(names, "张三丰","张无忌","周芷若","赵敏","张强");
              Stream<String> stream = names.stream();
      
      ```

  - Set集合的

    - Stream<E> stream()

    - ```java
      Set<String> set = new HashSet<>();
              Collections.addAll(set, "刘德华","张曼玉","蜘蛛精","马德","德玛西亚");
              Stream<String> stream1 = set.stream();
              stream1.filter(s -> s.contains("德")).forEach(s -> System.out.println(s));
      //filter():过滤Stream流，包含德才能留下
      
      ```

      

  - Map集合的

    - Stream方法是collection提供，map集合不属于collection，不可以直接调用

    - ```java
      Map<String, Double> map = new HashMap<>();
              map.put("古力娜扎", 172.3);
              map.put("迪丽热巴", 168.3);
              map.put("马尔扎哈", 166.3);
              map.put("卡尔扎巴", 168.3);
      
              Set<String> keys = map.keySet();
              Stream<String> ks = keys.stream();
      
              Collection<Double> values = map.values();
              Stream<Double> vs = values.stream();
      //values.stream()回车
              Set<Map.Entry<String, Double>> entries = map.entrySet();
              Stream<Map.Entry<String, Double>> kvs = entries.stream();
      //整体处理
              kvs.filter(e -> e.getKey().contains("巴"))
                      .forEach(e -> System.out.println(e.getKey()+ "-->" + e.getValue()));
      //键包含巴
      
      ```

      

- 获取数组的

  - ```java
    String[] names2 = {"张翠山", "东方不败", "唐大山", "独孤求败"};
    //方法1 Arrays类
            Stream<String> s1 = Arrays.stream(names2);
    //方法2 Stream类
            Stream<String> s2 = Stream.of(names2);
        }
    }
    
    ```

###### 3.3.1.2、中间方法

调用完成后会返回新的 Stream 流，可以继续使用 ( 支持链式编程 ) 。

| Stream提供的常用中间方法                                  | 说明                                        |
| --------------------------------------------------------- | ------------------------------------------- |
| Stream<T> filter(Predicate<? super T>predicate)           | 流中的数据进行过滤(xx.stream().filter(s->)) |
| Stream(T) sourted()                                       | 对元素进行升序排序                          |
| Stream(T) sorted(Comparator<? super T> comparator)        | 按照指定规则排序                            |
| Stream(T) limit(long maxSize)                             | 获取前几个元素                              |
| Stream(T) skip(long n)                                    | 跳过前几个元素                              |
| Stream(T) distinct()                                      | 去除流中重复的元素。                        |
| <R> Stream<R> map(Function<? super T,? extends R> mapper) | 对元素进行加工，并返回对应的新流            |
| static <T> Stream<T> concat(Stream a, Stream b)           | 合并 a 和 b 两个流为一个流                  |

 示例：

```java
/**
 * 目标：掌握Stream流提供的常见中间方法。
 */
public class StreamTest3 {
    public static void main(String[] args) {
        List<Double> scores = new ArrayList<>();
        Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0);
        // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。
        scores.stream().filter(s -> s >= 60).sorted().forEach(s -> System.out.println(s));

        List<Student> students = new ArrayList<>();
        Student s1 = new Student("蜘蛛精", 26, 172.5);
        Student s2 = new Student("蜘蛛精", 26, 172.5);
        Student s3 = new Student("紫霞", 23, 167.6);
        Student s4 = new Student("白晶晶", 25, 169.0);
        Student s5 = new Student("牛魔王", 35, 183.3);
        Student s6 = new Student("牛夫人", 34, 168.5);
        Collections.addAll(students, s1, s2, s3, s4, s5, s6);
        // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.
        students.stream().filter(s -> s.getAge() >= 23 && s.getAge() <= 30)
                .sorted((o1, o2) -> o2.getAge() - o1.getAge())
                .forEach(s -> System.out.println(s));

        // 需求3：取出身高最高的前3名学生，并输出。
        students.stream().sorted((o1, o2) -> Double.compare(o2.getHeight(), o1.getHeight()))
                .limit(3).forEach(System.out::println);
        System.out.println("-----------------------------------------------");

        // 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6
        students.stream().sorted((o1, o2) -> Double.compare(o2.getHeight(), o1.getHeight()))
                .skip(students.size() - 2).forEach(System.out::println);

        // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。
        students.stream().filter(s -> s.getHeight() > 168).map(Student::getName)
               .distinct().forEach(System.out::println);

        // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）
        students.stream().filter(s -> s.getHeight() > 168)
                .distinct().forEach(System.out::println);

        Stream<String> st1 = Stream.of("张三", "李四");
        Stream<String> st2 = Stream.of("张三2", "李四2", "王五");
        Stream<String> allSt = Stream.concat(st1, st2);
        allSt.forEach(System.out::println);
    }
}

```

###### 3.3.1.3、终结方法

调用完成后，不会返回新 Stream 了，没法继续使用流了

| Stream提供的常用终结方法                          | 说明                                     |
| ------------------------------------------------- | ---------------------------------------- |
| void forEach（                                    | 遍历                                     |
| long count()                                      | 统计此流运算后的元素个数                 |
| Optional<T> max(Comparator<? super T> comparator) | 获取此流运算后的最大值元素               |
| Optional<T> min(Comparator<? super T> comparator) | 获取此流运算后的最小值元素               |
| R collect(Collector collector)                    | 把流处理后的结果收集到一个指定的集合中去 |
| Object[ ] toArracy                                | 把流处理后的结果收集到一个数组中去       |

| Collectors工具类提供了具体的收集方式                         | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| public static <T> Collector toList ()                        | 把元素收集到 List 集合中 |
| public static <T> Collector toSet ()                         | 把元素收集到 Set集合中   |
| public static Collector toMap (Function keyMapper , Function valueMapper) | 把元素收集到 map集合中   |

示例：

```java
/**
 * 目标：Stream流的终结方法
 */
public class StreamTest4 {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        Student s1 = new Student("蜘蛛精", 26, 172.5);
        Student s2 = new Student("蜘蛛精", 26, 172.5);
        Student s3 = new Student("紫霞", 23, 167.6);
        Student s4 = new Student("白晶晶", 25, 169.0);
        Student s5 = new Student("牛魔王", 35, 183.3);
        Student s6 = new Student("牛夫人", 34, 168.5);
        Collections.addAll(students, s1, s2, s3, s4, s5, s6);
        // 需求1：请计算出身高超过168的学生有几人。
        long size = students.stream().filter(s -> s.getHeight() > 168).count();
        System.out.println(size);

        // 需求2：请找出身高最高的学生对象，并输出。
        Student s = students.stream().max((o1, o2) -> Double.compare(o1.getHeight(), o2.getHeight())).get();
        System.out.println(s);

        // 需求3：请找出身高最矮的学生对象，并输出。
        Student ss = students.stream().min((o1, o2) -> Double.compare(o1.getHeight(), o2.getHeight())).get();
        System.out.println(ss);

        // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。
        // 流只能收集一次。
        List<Student> students1 = students.stream().filter(a -> a.getHeight() > 170).collect(Collectors.toList());
        System.out.println(students1);

        Set<Student> students2 = students.stream().filter(a -> a.getHeight() > 170).collect(Collectors.toSet());
        System.out.println(students2);

        // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。
        Map<String, Double> map =
                students.stream().filter(a -> a.getHeight() > 170)
                        .distinct().collect(Collectors.toMap(a -> a.getName(), a -> a.getHeight()));
        System.out.println(map);

        // Object[] arr = students.stream().filter(a -> a.getHeight() > 170).toArray();
        Student[] arr = students.stream().filter(a -> a.getHeight() > 170).toArray(len -> new Student[len]);
        System.out.println(Arrays.toString(arr));
    }
}

```

### 4、io流（一）(java.io)

#### 4.1、File

存储数据的方案

* 变量
* 数组
* 对象
* 集合

断电、程序终止会丢失

* 文件是非常重要的存储方式，在计算机硬盘中。即便断电，或者程序终止了，存储在硬盘文件中的数据也不会丢失
* File是 java.io. 包下的类， File 类的对象，用于**代表当前操作系统的文件**（可以是文件、或文件夹）
* **File 类只能对文件本身进行操作，不能读写文件里面存储的数据**
* **File代表文本；Io流读写数据**

##### 4.1.1、创建对象

示例：

```Java
/**
 * 目标：掌握File创建对象，代表具体文件的方案。
 */
public class FileTest1 {
    public static void main(String[] args) {
        // 1、创建一个File对象，指代某个具体的文件。
        // 路径分隔符
        // File f1 = new File("D:/resource/ab.txt");
        // File f1 = new File("D:\\resource\\ab.txt");
        File f1 = new File("D:" + File.separator +"resource" + File.separator + "ab.txt");
        System.out.println(f1.length()); // 文件大小。字节个数

        File f2 = new File("D:/resource");
        System.out.println(f2.length());

        // 注意：File对象可以指代一个不存在的文件路径
        File f3 = new File("D:/resource/aaaa.txt");
        System.out.println(f3.length());
        System.out.println(f3.exists()); // false

        // 我现在要定位的文件是在模块中，应该怎么定位呢？
        // 绝对路径：带盘符的
        // File f4 = new File("D:\\code\\javasepromax\\file-io-app\\src\\itheima.txt");
        // 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。
        File f4 = new File("file-io-app\\src\\itheima.txt");
        //（重要）
        System.out.println(f4.length());
    }
}

```



##### 4.1.2、常用方法

###### 4.2.2.1、判断文件类型、获取文件信息

| 方法名称                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public boolean exists()         | 判断当前文件对象，对应的文件路径是否存在，存在返回 true      |
| public boolean isFile()         | 判断前文件对象指代的是否是文件，是文件返回 true ，反之       |
| public boolean isDirectory()    | 判断当前文件对象指代的是否是文件夹，是文件夹返回 true ，反之 |
| public String getName()         | 获取文件的名称（包含后缀）                                   |
| public long length()            | 获取文件的大小，返回字节个数                                 |
| public long lastModified()      | 获取文件的最后修改时间                                       |
| public String getPath()         | 获取创建文件对象时，使用的路径                               |
| public String getAbsolutePath() | 获取绝对路径                                                 |

示例：

```java
File f1 = new File("D:/resource/ab.txt");

// 5.public String getName()：获取文件的名称（包含后缀）
System.out.println(f1.getName());

// 6.public long length()：获取文件的大小，返回字节个数
System.out.println(f1.length());

// 7.public long lastModified()：获取文件的最后修改时间。
long time = f1.lastModified();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
System.out.println(sdf.format(time));

// 8.public String getPath()：获取创建文件对象时，使用的路径
File f2 = new File("D:\\resource\\ab.txt");
File f3 = new File("file-io-app\\src\\itheima.txt");
System.out.println(f2.getPath());
System.out.println(f3.getPath());

// 9.public String getAbsolutePath()：获取绝对路径
System.out.println(f2.getAbsolutePath());
System.out.println(f3.getAbsolutePath());

```

###### 4.2.2.2、创建文件、删除文件

| 方法名                         | 说明                 |
| ------------------------------ | -------------------- |
| public boolean createNewFile() | 创建一个新的空的文件 |
| public boolean mkdir()         | 只能创建一级文件夹   |
| public boolean mkdirs()        | 可以创建多级文件夹   |
| public boolean delete()        | 删除文件、空文件夹   |

示例：

```java
/**
 * 目标：掌握File创建和删除文件相关的方法。
 */
public class FileTest3 {
    public static void main(String[] args) throws Exception {
        // 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。
        File f1 = new File("D:/resource/itheima2.txt");
        System.out.println(f1.createNewFile());

        // 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹
        File f2 = new File("D:/resource/aaa");
        System.out.println(f2.mkdir());

        // 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹
        File f3 = new File("D:/resource/bbb/ccc/ddd/eee/fff/ggg");
        System.out.println(f3.mkdirs());

        // 3、public boolean delete()：删除文件，或者空文件夹，注意：不能删除非空文件夹。删除后的文件不会进入回收站
        System.out.println(f1.delete());
        System.out.println(f2.delete());
        File f4 = new File("D:/resource");
        System.out.println(f4.delete());
    }
}

```



###### 4.2.2.3、遍历文件夹

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| public String[] list()    | 获取当前目录下所有的 " 一级文件名称 " 到一个**字符串数组**中去返回 |
| public File[] listFiles() | 获取当前目录下所有的 " 一级文件对象 " 到一个**文件对象数组**中去返回（重点） |

示例：

```java
/**
 * 目标：掌握File提供的遍历文件夹的方法。
 */
public class FileTest4 {
    public static void main(String[] args) {
        // 1、public String[] list()：获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。
        File f1 = new File("D:\\course\\待研发内容");
        String[] names = f1.list();
        for (String name : names) {
            System.out.println(name);
        }

        // 2、public File[] listFiles():（重点）获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点）
        File[] files = f1.listFiles();
        for (File file : files) {
            System.out.println(file.getAbsolutePath());
        }

        File f = new File("D:/resource/aaa");
        File[] files1 = f.listFiles();
        System.out.println(Arrays.toString(files1));
    }
}

```

1. 当主调是文件时，或者路径不存在时，返回null
2. 当主调是空文件夹时，返回一个长度为0的数组
3. **当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回**
4. 当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件
5. 当主调是一个文件夹，但是没有权限访问时，返回null

#### 4.2、递归（多级处理文件）

直接递归；间接递归

递归算法三要素：

* 递归的公式： f(n) = f(n-1) * n;
* 递归的终结点： f(1)
* 递归的方向必须走向终结点：![image-20231011235638120](https://gitee.com/coi4/test/raw/master/img/image-20231011235638120.png)

##### 4.2.1、案例

1. 计算n的阶乘

   > 计算 n 的阶乘， 5 的阶乘 =1*2*3*4*5; 6 的阶乘 =1*2*3*4*5*6 

   ```java
   /**
    * 目标：掌握递归的应用，执行流程和算法思想。
    */
   public class RecursionTest2 {
       public static void main(String[] args) {
           System.out.println("5的阶乘是：" + f(5));
       }
   
       //求n个数的阶乘
       public static int f(int n){
           // 终结点
           if(n == 1){
               return 1;
           }else {
               return f(n - 1) * n;
           }
       }
   }
   ```

   

2. 递归求1-n的和

   分析 : 我们先从数学思维上理解递归的流程和核心点
   ① 假如我们认为存在一个公式是 f(n) = 1 + 2 + 3 + 4 + 5 + 6 + 7 + ...(n-1) + n;
   ② 那么公式等价形式就是： f(n) = f(n-1) + n
   ③ 递归的终结点： f(1) = 1
   ④ 递归的方向

3. 猴子吃桃问题

   > 猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个
   > 第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个
   > 以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个
   > 等到第 10 天的时候发现桃子只有 1 个了。
   > 需求：请问猴子第一天摘了多少个桃子？

   分析：
   ① 整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：
   ② 递归公式：
   ③ 递归终结点：
   ④ 递归方向：

4. 文件搜索

   > 从 D: 盘中，搜索“ QQ.exe” 这个文件，找到后直接输出其位置。

   ```java
   /**
    * 目标：掌握文件搜索的实现。
    */
   public class RecursionTest3 {
       public static void main(String[] args) throws Exception {
             searchFile(new File("D:/") , "QQ.exe");
       }
   
       /**
        * 去目录下搜索某个文件
        * @param dir  目录
        * @param fileName 要搜索的文件名称
        */
       public static void searchFile(File dir, String fileName) throws Exception {
           // 1、把非法的情况都拦截住
           if(dir == null || !dir.exists() || dir.isFile()){
               return; // 代表无法搜索
           }
   
           // 2、dir不是null,存在，一定是目录对象。
           // 获取当前目录下的全部一级文件对象。
           File[] files = dir.listFiles();
   
           // 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。
           if(files != null && files.length > 0){
               // 4、遍历全部一级文件对象。
               for (File f : files) {
                   // 5、判断文件是否是文件,还是文件夹
                   if(f.isFile()){
                       // 是文件，判断这个文件名是否是我们要找的
                       if(f.getName().contains(fileName)){
                           System.out.println("找到了：" + f.getAbsolutePath());
                           Runtime runtime = Runtime.getRuntime();
                           runtime.exec(f.getAbsolutePath());
                           //启动文件
                       }
                   }else {
                       // 是文件夹，继续重复这个过程（递归）
                       searchFile(f, fileName);
                   }
               }
           }
       }
   }
   
   ```

   

5. 啤酒问题

   > 啤酒 2 元 1 瓶， 4 个盖子可以换一瓶， 2 个空瓶可以换一瓶，
   > 请问 10 元钱可以喝多少瓶酒，剩余多少空瓶和盖子。15/3/1

```java


```

#### 4.3、字符集

##### 4.3.1、常见字符集

- ASCII 字符集：只有英文、数字、符号等，**占 1 个字节。**
- GBK 字符集：汉字占 2 个字节，英文、数字占 1 个字节。
- UTF-8 字符集：汉字占 3 个字节，英文、数字占 1 个字节。

编码时的字符集和解码时使用的必须一致，否则会出现字符乱码

英文，数字一般不会乱码，因为很多字符集都兼容了 ASCII 编码

##### 4.3.2、编码解码操作方法

编码：把**字符串**按照指定的字符集**转换为字节数组**
解码：把**字节数组**按照指定的字符集**转换为字符串**

| String提供了如下方法                     | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| byte[] getBytes()                        | 使用平台的默认字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |
| String(byte[]ytes)                       | 通过使用平台的默认字符集解码指定的字节数组来构造新的 String  |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String          |

示例：

```java
/**
 * 目标：掌握如何使用Java代码完成对字符的编码和解码。
 */
public class Test {
    public static void main(String[] args) throws Exception {
        // 1、编码
        String data = "a我b";
        byte[] bytes = data.getBytes(); // 默认是按照平台字符集（UTF-8）进行编码的。
        System.out.println(Arrays.toString(bytes));

        // 按照指定字符集进行编码。
        byte[] bytes1 = data.getBytes("GBK");
        System.out.println(Arrays.toString(bytes1));

        // 2、解码
        String s1 = new String(bytes); // 按照平台默认编码（UTF-8）解码
        System.out.println(s1);

        String s2 = new String(bytes1, "GBK");
        System.out.println(s2);
    }
}

```

### 5、io流（二）

![image-20231219112532709](https://gitee.com/coi4/test/raw/master/img/image-20231219112532709.png)

字节流适合做一切文件数据的拷贝（音视频、文本）；字节流不适合读取中文内容输出

字符流适合做文本文件的操作（读、写）

#### 5.1、字符流

文件字符输入流-读字符数据进来

FileReader：以内存为基础，把文件中的数据以字符的形式读入到内存中

![image-20231219112711984](https://gitee.com/coi4/test/raw/master/img/image-20231219112711984.png)

![屏幕截图 2023-12-19 112720](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-19%20112720.png)

文件字符输出流-写字符数据出去

FileWriter：以内存为基础，把内存中的数据以字符的形式写出到文件中去

![image-20231219112926752](https://gitee.com/coi4/test/raw/master/img/image-20231219112926752.png)

![image-20231219112939561](https://gitee.com/coi4/test/raw/master/img/image-20231219112939561.png)

字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效

![image-20231219113029424](https://gitee.com/coi4/test/raw/master/img/image-20231219113029424.png)

#### 5.2、缓冲流

![image-20231219113312815](https://gitee.com/coi4/test/raw/master/img/image-20231219113312815.png)

对原始流进行包装，提高原始流读写数据的性能

字节缓冲流：字节缓冲输入流自带8KB缓冲池，字节缓冲输出流也![image-20231219113441309](https://gitee.com/coi4/test/raw/master/img/image-20231219113441309.png)

字符缓冲流：自带8K

BufferedReader、BufferedWriter

![image-20231219113618493](https://gitee.com/coi4/test/raw/master/img/image-20231219113618493.png)

![image-20231219113631593](https://gitee.com/coi4/test/raw/master/img/image-20231219113631593.png)

![image-20231219113702789](https://gitee.com/coi4/test/raw/master/img/image-20231219113702789.png)

![image-20231219113713167](https://gitee.com/coi4/test/raw/master/img/image-20231219113713167.png)

案例：拷贝出师表到另一个文件，恢复顺序

需求：把出师表的文章顺序进行恢复到另一个新文件

分析：

- 定义一个缓存字符输入流管道与源文件接通
- 定义一个List集合存储读取每行数据
- 定义循环按照行读取，存入到List中
- 对List每行数据按照首字母编号升序排序
- 定义缓存字符输出管道与目标文件接通
- 遍历List集合中的每个元素，用缓冲输出管道写出并换行

原始流、缓冲流的性能分析：分别使用原始的字节流和字节缓冲流复制一个很大的视频

步骤：

- 使用低级的字节流按照一个一个字节的形式复制
- 使用低级字节流按照字节数组的形式复制
- 使用高级一个一个
- 使用高级按数组

建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式

#### 5.3、转换流

![image-20231219114428739](https://gitee.com/coi4/test/raw/master/img/image-20231219114428739.png)

不同编码读取时会乱码——先获取文件的原始字节流，再将按照真实的字符集编码转成字符输入流

字符输入转换流![image-20231219114522691](https://gitee.com/coi4/test/raw/master/img/image-20231219114522691.png)

字符输出转换流

![image-20231219114556441](https://gitee.com/coi4/test/raw/master/img/image-20231219114556441.png)

![image-20231219114622192](https://gitee.com/coi4/test/raw/master/img/image-20231219114622192.png)

#### 5.4、打印流

![image-20231219114642494](https://gitee.com/coi4/test/raw/master/img/image-20231219114642494.png)

![image-20231219114919174](https://gitee.com/coi4/test/raw/master/img/image-20231219114919174.png)

![image-20231219114941897](https://gitee.com/coi4/test/raw/master/img/image-20231219114941897.png)

![image-20231219115106411](https://gitee.com/coi4/test/raw/master/img/image-20231219115106411.png)

#### 5.5、数据流

![image-20231219115131417](https://gitee.com/coi4/test/raw/master/img/image-20231219115131417.png)

允许把数据和其类型一并写出去

![image-20231219115214944](https://gitee.com/coi4/test/raw/master/img/image-20231219115214944.png)

![image-20231219115246943](https://gitee.com/coi4/test/raw/master/img/image-20231219115246943.png)

#### 5.6、序列化流

![image-20231219115406439](https://gitee.com/coi4/test/raw/master/img/image-20231219115406439.png)

对象序列化：把java对象写入到文件中去

对象反序列化：把文件里的java对象读出去

对象如果要参与序列化，必须实现序列化接口

![image-20231219115425915](https://gitee.com/coi4/test/raw/master/img/image-20231219115425915.png)

![image-20231219115508843](https://gitee.com/coi4/test/raw/master/img/image-20231219115508843.png)

一次序列化多一个对象：用ArrayList集合存储多个对象，然后直接对集合进行序列化即可（ArrayList集合已经实现了序列化接口

#### 5.7、IO框架

框架：解决某类问题，编写的一套类、接口等，半成品

在框架的基础上开发，可以得到优秀的软件架构并提法开发性能

形式：一般是把类、接口等编译成class形式，在压缩成.jar结尾的文件发行出去

io框架：封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式对文件进行操作，对数据进行读写等

Commons-io：![image-20231219115941759](https://gitee.com/coi4/test/raw/master/img/image-20231219115941759.png)

![image-20231219115959089](https://gitee.com/coi4/test/raw/master/img/image-20231219115959089.png)

步骤：导入commons-io-2.11.0.jar框架到项目中

1. 创建文件夹：lib
2. 将。jar文件复制到lib文件夹
3. 在jar文件上右击，选择Add as Library，点击ok
4. 在类中导包使用

### 6、特殊文件

#### 6.1、Properties文件

##### 6.1.1、操作

- 创建properties属性文件

* 用Properties读取属性文件

  1. **创建**properties**对象**

  2. 加载properties属性**文件**中键值对数据**到对象**中去(用字符集)

     - ```java
       .load(new FilerReader(""))
       ```

  3. 通过键**取值**

     - ```java
       .getProperty("键名")
       ```

  4. **获取键全部集合遍历并输出**

     ```
     properties.
     ```

  5. 

* 

#### 6.2、xml文件

用来存储复杂的数据结构，和数据关系

作为软件的配置文件

![image-20231012211300216](https://gitee.com/coi4/test/raw/master/img/image-20231012211300216.png)

##### 6.2.1、文件内书写格式

- 文件内第一行必须为

```
<?xml version="1.0" encoding="UTF-8" ?>

```

- 注释

  ```
  <!--    -->
  ```

- 特殊符号报错

  ```
  <![CDATA[内容。。。]]>
  //CD回车
  ```

- 根标签只能有一个

##### 6.2.2、读取文件数据

1. 准备工作

   - 下载dom4j框架（官网下最新版）；下载第一个核心文件jar即可
   - 项目中创建Directory文件夹，复制过来
   - jar文件右键，选Add as Library -> 点击 OK

2. 用dom4j解析xml，得到document对象，

   | 构造器/方法                                | 说明                                                         |
   | ------------------------------------------ | ------------------------------------------------------------ |
   | public SAXReader() public                  | 构建 Dom4J 的解析器对象                                      |
   | *Document **read**(String url)             | 把 XML 文件读成 Document 对象                                |
   | public Document read(InputStream<br/>is)   | 通过字节输入流读取 XML 文件                                  |
   | Element getRootElement()                   | 获取根元素对象                                               |
   | public String getName()                    | 得到元素名字                                                 |
   | public List<Element> elements()            | 得到当前元素下所有子元素                                     |
   | public List<Element> elements(String name) | 得到当前元素下指定名字的子元素返回集合                       |
   | public Element element(String name)        | 得到当前元素下指定名字的子元素 , 如果有很多名字相同的返回第一个 |
   | public String attributeValue(String name)  | 通过属性名直接得到属性值                                     |
   | public String elementText( 子元素名 )      | 得到指定名称的子元素的文本                                   |
   | public String getText()                    | 得到文本                                                     |

   

##### 6.2.3、把数据写到xml文件中去

用io流

```java
public class Dom4JTest2 {
    public static void main(String[] args) {
        // 1、使用一个StringBuilder对象来拼接XML格式的数据。
        StringBuilder sb = new StringBuilder();
        sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n");
        sb.append("<book>\r\n");
        sb.append("\t<name>").append("从入门到跑路").append("</name>\r\n");
        sb.append("\t<author>").append("dlei").append("</author>\r\n");
        sb.append("\t<price>").append(999.99).append("</price>\r\n");
        sb.append("</book>");

        try (
                BufferedWriter bw = new BufferedWriter(new FileWriter("properties-xml-log-app/src/book.xml"));
                ){
            bw.write(sb.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

```

### 7、日志技术

* 通常就是一个文件，里面记录的是程序运行过程中的各种信息，可以永久存储
* 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改。

日志技术：

* 日志框架：Logback（Logback 是基于 slf4j 的日志规范实现的框架）
  * 要使用该框架，至少需要在项目中整合三个模块
    * slf4j-api：日志接口
    * logback-core：基础模块
    * logback-classic：功能模块
* 日志接口：slf4j

#### 7.1、快速入门

![image-20231012221946603](https://gitee.com/coi4/test/raw/master/img/image-20231012221946603.png)

#### 7.2、*设置日志级别

日志级别指的是**日志信息的类型**，用于**控制系统中哪些日志级别是可以输出的**，日志都会分级别，常见的日志级别如下（优先级依次升高）

| 日志级别 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trace    | 追踪，指明程序运行轨迹                                       |
| debug    | 调试，实际应用中一般将其作为最低级别，而 trace 则很少使用    |
| *info    | 输出重要的运行信息，数据连接、网络连接、 IO 操作等等，使用较多 |
| *warn    | 警告信息，可能会发生问题，使用较多                           |
| *error   | 错误信息 , 使用较多                                          |

![image-20231012223848578](https://gitee.com/coi4/test/raw/master/img/image-20231012223848578.png)

只有日志级别大于或等于该级别，才会被输出

```java
public class LogBackTest {
    // 创建一个Logger日志对象
    public static final Logger LOGGER = LoggerFactory.getLogger("LogBackTest");

    public static void main(String[] args) {
        //while (true) {
            try {
                LOGGER.info("chu法方法开始执行~~~");
                chu(10, 0);
                LOGGER.info("chu法方法执行成功~~~");
            } catch (Exception e) {
                LOGGER.error("chu法方法执行失败了，出现了bug~~~");
            }
        //}
    }

    public static void chu(int a, int b){
        LOGGER.debug("参数a:" + a);
        LOGGER.debug("参数b:" + b);
        int c = a / b;
        LOGGER.info("结果是：" + c);
    }
}

```

![屏幕截图 2023-10-12 224327](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-12%20224327.png)

![屏幕截图 2023-10-12 224351](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-12%20224351.png)

### 8、多线程(java.lang)

线程是一个程序内部的一条执行流程

多线程指从软硬件上实现的多条执行流程的技术

* 12306同时可以有多人一起进入购票，每个人互不影响；百度网盘可以同时下载或上传多个文件；

#### 8.1、线程创建方式

##### 8.1.1、方式一：继承Thread类

不利于功能拓展

![image-20231012225824454](https://gitee.com/coi4/test/raw/master/img/image-20231012225824454.png)

不要把主线程任务放在启动子线程之前

```java
public class MyThread extends Thread{
    // 2、必须重写Thread类的run方法
    @Override
    public void run() {
        // 描述线程的执行任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程MyThread输出：" + i);
        }
    }
}
```

```java
public class ThreadTest1 {
    // main方法是由一条默认的主线程负责执行。
    public static void main(String[] args) {
        // 3、创建MyThread线程类的对象代表一个线程
        Thread t = new MyThread();
        // 4、启动线程（自动执行run方法的）
        t.start(); 

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出：" + i);
        }
    }
}
```

![image-20231012230801218](https://gitee.com/coi4/test/raw/master/img/image-20231012230801218.png)

##### 8.1.2、方式二：实现Runnable接口

如果线程有执行结果不能直接返回

![image-20231012230856411](https://gitee.com/coi4/test/raw/master/img/image-20231012230856411.png)

```java
/**
 * 1、定义一个任务类，实现Runnable接口
 */
public class MyRunnable implements Runnable{
    // 2、重写runnable的run方法
    @Override
    public void run() {
        // 线程要执行的任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程输出 ===》" + i);
        }
    }
}
```

```java
public class ThreadTest2 {
    public static void main(String[] args) {
        // 3、创建任务对象。
        Runnable target = new MyRunnable();
        // 4、把任务对象交给一个线程对象处理。
        //  public Thread(Runnable target)
        new Thread(target).start();

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出 ===》" + i);
        }
    }
}
```

```java
public class ThreadTest2_2 {
    public static void main(String[] args) {
        // 1、直接创建Runnable接口的匿名内部类形式（任务对象）
        Runnable target = new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程1输出：" + i);
                }
            }
        };
        new Thread(target).start();

        // 简化形式1：
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程2输出：" + i);
                }
            }
        }).start();

        // 简化形式2：
        new Thread(() -> {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程3输出：" + i);
                }
        }).start();

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出：" + i);
        }
    }
}

```

![img](https://gitee.com/coi4/test/raw/master/img/_807729572__b41ccd9f106189d24140b8bc222089d9_2064002851_Screenshot_20231012_231645_0_xg_0.jpg)

##### 8.1.3、方式三：实现Calloble接口

可以返回线程执行完毕后的结果

代码复杂

![image-20231012231749871](https://gitee.com/coi4/test/raw/master/img/image-20231012231749871.png)

```java
public class ThreadTest3 {
    public static void main(String[] args) throws Exception {
        // 3、创建一个Callable的对象
        Callable<String> call = new MyCallable(100);
        // 4、把Callable的对象封装成一个FutureTask对象（任务对象）
        // 未来任务对象的作用？
        // 1、是一个任务对象，实现了Runnable对象.
        // 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。
        FutureTask<String> f1  = new FutureTask<>(call);
        // 5、把任务对象交给一个Thread对象
        new Thread(f1).start();


        Callable<String> call2 = new MyCallable(200);
        FutureTask<String> f2  = new FutureTask<>(call2);
        new Thread(f2).start();


        // 6、获取线程执行完毕后返回的结果。
        // 注意：如果执行到这儿，假如上面的线程还没有执行完毕
        // 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。
        String rs = f1.get();
        System.out.println(rs);

        String rs2 = f2.get();
        System.out.println(rs2);
    }
}

```

#### 8.2、Thread常用方法

| 构造器/方法                                 | 说明                                            |
| ------------------------------------------- | ----------------------------------------------- |
| public Thread（String name）                | 可以为当前线程指定名称                          |
| *public Thread(Runnable target)             | 封装 Runnable 对象成为线程对象                  |
| public Thread(Runnable target, String name) | 封装 Runnable 对象成为线程对象，并指定线程名称  |
| public void run()                           | 线程的任务方法                                  |
| public void start()                         | 启动线程                                        |
| *public String getName()                    | 获取当前线程的名称，线程名称默认是 Thread- 索引 |
| *public void setName(String name)           | 为线程设置名称                                  |
| *public static Thread currentThread()       | 获取当前执行的线程对象                          |
| *public static void sleep(long time)        | 让当前执行的线程休眠多少毫秒后，再继续执行      |
| public final void join()...                 | 让调用当前这个方法的线程先执行完！              |

### 9、网络通信（Java.net)

网络编程：可以让设备中的程序与网络上其他设备中的程序进行**数据交互**（实现网络通信）

**java.net.*包**下提供了网络编程的解决方案

基本通信架构：

- cs架构（Client 客户端 /Server 服务端）
  - Client客户端需要程序员开发（微信）
- BS 架构 (Browser 浏览器 /Server
  服务端 )
  - Browser浏览器不需要程序员开发实现（ie、火狐、360）

无论哪个架构都必须依赖网络通信

#### 9.1、三要素

##### 9.1.1、IP地址

* 设备在网络中的地址，是唯一的标识
* 全称：互联网协议地址
* 两种形式：
  * IPv4：共123位
  * IPv6：分8段表示，每段每四位编码成一个十六进制位表示，数之间用冒号隔开
* 公网IP：是可以连接互联网的 IP 地址
* 内网 IP ：也叫局域网 IP ，只能组织机构内部使用；192.168开头的就是常见的局域网地址，范围为192.168.0.0-192.168.255.255
* 特殊IP地址：127.0.0.1、Iocalhost；代表本机IP，只会寻找当前所在的主机

常用命令：

- ipconfig：查看本机IP地址
- ping IP：检查网络是否连通

InetAddress（IP地址的代表类）常用方法：

| 名                                                 | 说明                                             |
| -------------------------------------------------- | ------------------------------------------------ |
| public static InetAddress getLocalHost（）         | 获取本机IP                                       |
| public static InetAddress getByName（String host） | 根据ip地址或域名，返回InetAddress对象            |
| public String getHostName（）                      | 获取该ip地址对象对应的主机名                     |
| public String getHostAddress（）                   | 获取该IP地址对象中的IP地址信息                   |
| public boolean isReachable（int timeout）          | 在指定毫秒内，判断主机与该ip地址的主机是否能连通 |

##### 9.1.2、端口号

应用程序在设备中唯一的标识，规定为16位的二进制，范围是0~65535

- 周知端口：0~1023，被预先定义的知名应用占用（HTTP占用80，FTP占用21）
- 注册端口：1024~49151，分配给用户进程或某些应用程序
- 动态端口：49152~65535，一般不固定分配某种进程，而是动态分配

注意：我们自己开发的程序一般选择使用**注册端口**，且一个设备中不能出现两个程序的端口号一样，否则出
错。

##### 9.1.3、协议

连接和数据在网络中传输的规则

为了让全球所有的上网设备都能互联

* OSI网络参考模型：开放式网络互联标准；全球网络互联标准

* TCP/IP网络模型：事实上的国际标准

  ![image-20231015165702855](https://gitee.com/coi4/test/raw/master/img/image-20231015165702855.png)

传输层2个通信协议：

* UDP协议（User Datagram protocal） ：
  * 无连接、不可靠通信、通信效率高（语音通话、视频直播）、一次最多发64k、数据不安全、容易丢失
  * 不是先建立连接，数据按照包发，一包数据包含：自己的ip、程序端口、目的地 IP 、程序端口和数据（限制在 64KB 内）等
  * 发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的
* TCP协议：
  * 面向连接、可靠通信、通信效率相对不高（网页、文件下载、支付）、连接中可进行大数据量的传输
  * 最终目的：保证在不可靠的信道上实现可靠的传输
  * 主要有三个步骤实现可靠传输：
    * 三次握手建立连接---确定通信双方收发消息正常（全双工）![image-20231015170635087](https://gitee.com/coi4/test/raw/master/img/image-20231015170635087.png)
    * 传输数据进行确认
    * 四次挥手断开连接---确保双方数据的收发都已经完成![image-20231015170741357](https://gitee.com/coi4/test/raw/master/img/image-20231015170741357.png)

#### 9.2、UDP通信快速入门

Java.net.DatagramSocket类实现

**DatagramSocket**：用于创建客户端、服务端

构造器：

| 构造器                              | 说明                                             |
| ----------------------------------- | ------------------------------------------------ |
| public DatagramSocket（）           | 创建客户端的Socket对象，系统会随机分配一个端口号 |
| public DatagramSocket（int   port） | 创建服务端的Socket对象，并指定端口号             |

方法：

| 名                                      | 说明               |
| --------------------------------------- | ------------------ |
| public void send（DatagramPacket dp）   | 发送数据包         |
| public void receive（DatagramPacket p） | 使用数据包接收数据 |

**DatagramPacket**：创建数据包

构造器：

| 构造器                                                       | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| public DatagramPacket（byte[] buf, int length,  InetAddress address,int port) | 创建发出去的数据包对象   |
| public DatagramPacket(byte[] buf,int length)                 | 创建用来接收数据的数据包 |

 方法：

| 名                       | 说明                             |
| ------------------------ | -------------------------------- |
| public int getLength（） | 获取数据包，实际接收到的字节个数 |

##### 9.2.1、案例

> 使用 UDP 通信实现：发送消息、接收消息

```
客户端：
① 创建 DatagramSocket 对象（客户端对象） 
② 创建 DatagramPacket 对象封装需要发送的数据（数据包对象） 
③ 使用 DatagramSocket 对象的 send 方法，传入 DatagramPacket 对象
④ 释放资源

服务端：
① 创建 DatagramSocket 对象并指定端口（服务端对象） 
② 创建 DatagramPacket 对象接收数据（数据包对象） 
③ 使用 DatagramSocket 对象的 receive 方法，传入 DatagramPacket 对象
④ 释放资源
```

#### 9.3、UDP通信多发多收

##### 9.3.1、案例

> 客户端可以反复发送数据

```
客户端实现步骤：
① 创建 DatagramSocket 对象（发送端对象） 
② 使用 while 死循环不断的接收用户的数据输入，如果用户输入的 exit 则退出程序
③ 如果用户输入的不是 exit, 把数据封装成 DatagramPacket 
④ 使用 DatagramSocket 对象的 send 方法将数据包对象进行发送 
⑤ 释放资源

接收端实现步骤：
① 创建 DatagramSocket 对象并指定端口（接收端对象） 
② 创建 DatagramPacket 对象接收数据（数据包对象） 
③ 使用 DatagramSocket 对象的 receive 方法传入 DatagramPacket 对象
④ 使用 while 死循环不断的进行第 3 步
```

#### 9.4、TCP通信快速入门

客户端开发：

Java.net.Socket类实现

| 构造器                                 | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| public Socket（String host，int port） | 根据指定的服务器ip、端口号请求与服务器建立连接，连接通过，就获得了客户端 socket |

| 方法名                                  | 说明               |
| --------------------------------------- | ------------------ |
| public OutputStream getOutputStream（） | 获得字节输出流对象 |
| public InputStream getInputStream（）   | 获得字节输入流对象 |

##### 9.4.1、客户端实操

> 客户端发送消息

```
① 创建客户端的 Socket 对象，请求与服务端的连接。
② 使用 socket 对象调用 getOutputStream() 方法得到字节输出流。
③ 使用字节输出流完成数据的发送。
④ 释放资源：关闭 socket 管道。
```

服务端程序的开发：

java.net.ServerSocket类实现

| 构造器                          | 说明             |
| ------------------------------- | ---------------- |
| public ServerSocket（int port） | 为服务端注册端口 |

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| public Socket accept（） | 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的 Socket 对象 |

##### 9.4.2、服务端案例

> 服务端实现接收消息

```
① 创建 ServerSocket 对象，注册服务端端口。
② 调用 ServerSocket 对象的 accept() 方法，等待客户端的连接，并得到 Socket 管道对象。
③ 通过 Socket 对象调用 getInputStream() 方法得到字节输入流、完成数据的接收。
④ 释放资源：关闭 socket 管道
```

#### 9.5、TCP通信多发多收

##### 9.5.1、实操

> 使用TCP通信实现多发多收消息

```
①客户端使用死循环，让用户不断输入消息。
②服务端也使用死循环，控制服务端收完消息，继续等待接收下一个消息。
```

#### 9.6、TCP通信同时接收多个客户端

* 主线程定义了循环负责接收客户端 Socket 管道连接
* 每接收到一个 Socket 通信管道后分配一个独立的线程负责处理
  它。

#### 9.7、TCP通信案例

> 即时通信-群聊

```

```

> 实现一个简易版的BS架构
>
> 要求从浏览器中访问服务器
> 并立即让服务器响应一个很简单的网页给浏览器
> 展示
> 网页内容就是“黑马程序员 666”

```

```

### 10、Java高级

#### 10.1、反射

允许以编程方式访问已加载类的成分（成员变量、方法、构造器等）；获取它们的信息，操作他们

反射：获取类——获取类的构造器——获取类的成员变量——成员方法

反射的基本作用，关键：反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分

反射的核心思想和关键：得到编译后的class文件对象

获取类的对象的三种方式：

- Class c1=Class.forname("全类名");
- Class c2=类名.class
- Class c3=对象.getClass();

类中获取构造器的方法:

- Constructor<T>[] getConstructors():返回所有构造器对象的数组(只能拿public)
- getDeclaredConstructors():返回所有构造器对象的数组,存在就能拿到
- getConstructor(Class<?>...parameterTypes):返回单个构造器对象(只能拿public)
- getDeclaredConstructor

Constructor类中用于创建对象的方法

- T newInstance(Object... initargs):根据指定的构造器创建对象
- void setAccessible(boolean flag):设置true,表示取消访问检查,进行暴力反射(非public构造器,需要暴力反射在创建对象)(反射可以破坏封装性,私有的也可以执行)

获取成员变量的方法:

- Field[] getFields():返回所有成员变量对象的数组(只能拿public)
- getDeclaredFields():返回所有,存在就能拿
- getField(String name):返回单个

Field类中用于取值、赋值的方法

- set(Object obj,Object value):赋值
- get(Object obj):获取值
- 如果某些成员变量是非public:setAccessible(boolean)

获取成员方法的方法:

- Method[] getMethods():返回所有成员方法对象的数组(只能拿public)
- getDeclaredMethods:
- getMethod
- getDeclaredMethod

Method类中用于触发执行的方法:

- Object invoke(Object obj,Object...args):参数一:用obj对象调用该方法,参数二:调用方法的传递的参数(没有就不写),返回值:方法的返回值(没有就不写))
- 非public:暴力后再触发执行

作用：反射是作用在运行时的技术，此时集合的泛型将不能产生约束，可以为集合存入其他任意类型的元素

- 可以在运行时得到一个类的全部成分然后去操作
- 可以破坏封装性
- 可以破坏泛型的约束性
- 做Java高级框架
- 基本上主流框架都会基于反射设计一些通用技术功能

泛型只在编译阶段可以约束集合只能操作某种数据类型，在编译成class文件进入运行阶段，其真实类型都是ArrayList，泛型被擦除

案例：反射做通用框架

需求：给你任意一对象，在不清楚对象字段的的情况可以把对象的字段名称和对应值存储到文件中去

- 定义一个方法，可以接受任意类的对象
- 每次收到一个对象后，需要解析这个对象的全部成员变量名称（使用反射获取对象的class类对象，获取全部成员变量信息，遍历成员变量信息，提取本成员变量在对象中的具体值，存入成员变量名称和值到文件中去）

#### 10.2、注解

Java注解（Annotation）又称Java标注，JDK5.0引入的一种注释机制

Java语言中的类、构造器、方法 、成员变量、参数等都可以被注解进行标注

自定义注解：自己做一个注解![屏幕截图 2023-12-15 153130](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-15%20153130.png)

作用：对Java中类、方法、成员变量做标记，然后进行特殊处理

特殊属性：value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写；如果有多个属性，且多个属性没有默认值，不可以省略

元注解：注解注解的注解

- @Target：约束自定义注解只能在哪些地方使用（标记的范围）
  - 可使用的值定义在ElementType枚举类中
  - 常用值：TYPE（类、接口），FIELD（成员变量），METHOD（方法），PARAMETER（方法参数），CONSTRUCTOR（构造器），LOCAL_VARIABLE(局部变量)
- @Retention：申明注解的生命周期（注解存活范围）
  - 定义在RetentionPolicy枚举类中
  - 常用值：SOURCE（注解只作用在源码阶段，生成的字节码文件中不存在），CLASS（作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值），RUNTIME（都（开发中常用））

注解的解析：判断是否存在注解，存在就解析输出内容

![image-20231219110636939](https://gitee.com/coi4/test/raw/master/img/image-20231219110636939.png)

- 相关接口：Anootation：注解的顶级接口，注解都是Annotion类型的对象；AnnotatedElement：定义了与注解解析相关的解析方法
  - 方法：
    - Annotion[] getDeclaredAnnotions（）：获取当前对象上使用的所有注解，返回注解数组
    - T getdeclaredAnnotation（Class<T>annotationClass):根据注解类型获得对应注解对象
    - boolean isAnnotationPresent(Class<Annotation>annotationClass):判断当前对象是否使用了指定的注解,如果用了返回true
  - 所有类成分Class,Method,Field,Construtor都实现了AnnotatedElement接口他们都拥有解析注解的能力
  - 解析注解的技巧:
    - 注解在哪个 成分上就先拿哪个成员对象

案例：

需求：注解解析的案例

- 分析：
  - 定义注解Book，要求如下：
    - 包含属性：String value（）书名
    - 包含属性：double price（）价格，默认值为100
    - 包含属性：String[] authors（）多位作者
    - 限制注解使用的位置：类和成员方法上
    - 指定注解的有效范围：RUNTIME
  - 定义BOokStore类，在类和成员方法上使用Book注解
  - 定义AnnotationDemo01测试类获取Book注解上的数据

应用场景：模拟Junit框架

需求：定义若干个方法，只要加了MyTest注解，就可以在启动时被触发执行

- 分析
  - 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在
  - 定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行

#### 10.3、动态代理

代理思想就是被代理者没有能力，或者不愿意去完成某件事情，需要找个人（代理）代替自己去完成

动态代理主要是对被代理对象的行为进行代理

![image-20231219111333276](https://gitee.com/coi4/test/raw/master/img/image-20231219111333276.png)

开发步骤：

1. 必须定义接口，里面定义一些行为，用来约束被代理对象和代理对象都要完成的事情
2. 定义一个实现类实现接口，这个实现类的对象代表被代理的对象
3. 定义测试类，创建被代理对象，然后为其创建一个代理对象返回
4. 代理对象中，需要模拟收首付款，真正触发被代理对象的行为，然后接收尾款操作
5. 通过返回代理对象进行方法的调用，观察动态代理的执行流程

![image-20231219111400097](https://gitee.com/coi4/test/raw/master/img/image-20231219111400097.png)

走向代理——代理中可以真正触发被代理对象的方法执行——回到代理中，有代理负责返回结果给调用者

应用案例：模拟企业业务功能开发，并完成每个功能的性能统计

需求：模拟某企业用户管理业务，需包含用户登录，删除，查询功能，并统计每个功能的耗时

- 分析：
  - 定义一个UserService表示业务接口，规定必须完成所有功能
  - 定义实现类UserSeervicelmpl，完成功能，且统计耗时
  - 定义测试类，创建类对象，调用方法
- 优化：
  - 必须有接口，实现类实现接口（代理通常基于接口实现）
  - 创建实现类对象（业务对象），为业务对象创建代理对象
  - ![image-20231219111948858](https://gitee.com/coi4/test/raw/master/img/image-20231219111948858.png)

动态代理优点

- 不改变方法源码的基础上，实现对方法功能的增强，提高代码复用
- 简化编程工作、提高开发效率，提高软件系统可扩展性
- 为被代理对象的所有方法做代理
- 非常灵活，支持任意接口类型的实现类对象做代理，也可以为本身做代理

#### 10.4、junit

编写测试代码对该功能进行正确性测试

Junit：单元测试框架

优点：

- 可以选择执行哪些测试方法，可以一键执行全部测试方法的测试
- 可以生成测试报告，通过绿色
- 单元测试中某个方法执行失败，不影响其他测试方法测试

快速入门：

- 将junit框架的jar包导入到项目中（Idea不需要手工导入）
- 编写测试类，测试类方法（测试方法必须公共，无参数，无返回值的非静态方法）
- 必须在测试方法上使用@Test注解
- 在测试方法中，编写程序调用被测试的方法即可
- 选中测试方法，**右键**选择“Junit”运行，如果测试通过则是绿色，失败红色
- 测试全部方法——选择类或者模块

常见注解：

- @Test，@Before（修饰实例方法，该方法会在每一个测试方法执行之前执行一次，Junit.4），@After，@BeforeClass（修饰静态方法，该方法会在所有测试方法之前只执行一次），@AfterClass，@BeforeEach（修饰实例方法，在每一个测试方法执行之前执行一次，Junit.5），@AfterEach，@BeforeAll，@AfterAll
- 开始执行的方法：初始化资源
- 执行完之后的方法：释放资源

## #其他

组件及事件处理





兑换时支付燃油费

未兑换自动退款（所有航线均为确认，最后一次航线推送兑换后15日内自动退款16号后）

兑换前实名认证会员（plus会员免费一件手提行李，一件托运行李，半价生舱）

根据推送目的地选择最想出行的城市，确认后不可更改

兑换方式：点击好物查看订单，点击兑换查看目的地，选择目的地，选择航班信息，支付并出票





