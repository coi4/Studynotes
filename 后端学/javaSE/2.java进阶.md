# Java进阶

## 一、面对对象进阶

写程序的套路——设计对象处理数据解决问题

### 1、Static

#### 1.1、修饰成员变量

成员变量按照有无static修饰分为：

- 类变量：有static修饰，属于类，在计算机中只有一份，会**被类的全部对象共享**
  - 只需要通过类名就可以调用：类名 .静态变量
- 实例变量（对象的变量）：无static修饰，**属于每个对象**
  - 需要通过对象才能调用:对象 .实例变量

执行原理:

![image-20231117153055889](https://gitee.com/coi4/test/raw/master/img/image-20231117153055889.png)

![image-20231117153109221](https://gitee.com/coi4/test/raw/master/img/image-20231117153109221.png)

应用场景:如果某个数据只需要一份,且希望能被共享(访问、修改)，则该数据可以定义成类变量记住

访问自己类中中的类变量，可以省略类名不写，在某个类中访问其他类里的类变量，必须带类名访问

案例：系统启动后，要求用户可以记住自己创建了多少个用户对象![image-20231117153307023](https://gitee.com/coi4/test/raw/master/img/image-20231117153307023.png)

#### 1.2、修饰成员方法

分类：

- 类方法（静态方法）：有static修饰的，属于类
- 实例方法：无，属于对象

main方法：类方法![image-20231117153630549](https://gitee.com/coi4/test/raw/master/img/image-20231117153630549.png)

应用场景：做工具类（工具类中的方法都是类方法，每个方法都是用来完成一个功能，给开发人员共同使用的）（实例方法才需要创建对象调用，为了调用方法要创建对象——浪费内存）

工具类没有创建对象的需求，建议将工具类的构造器进行私有

注意事项：

- 类方法中可以直接访问类的成员，不可以直接访问实例成员
- 实例方法中可以出现this关键字，类方法中不可以

#### 1.3、代码块

类的5大成分之一（成员变量、构造器、方法、代码块、内部类）

分为：

- 静态代码块：
  - 格式：static{}
  - 特点：**类加载时自动执行**，由于类只会加载一次，所以静态代码块也只会执行一次
  - 作用：完成**类的初始化**（例如：对类变量的初始化赋值）
- 实例代码块：
  - 格式{}
  - 特点：每次创建对象时，执行实例代码块，并在**构造器前执行**
  - 作用：和构造器一样，都是用来完成**对象的初始化**（例如：对实例变量进行初始化赋值）

#### 1.4、单例设计模式

设计模式：具体问题最优解法方案（20多种）

重点：解决什么问题？怎么写？

单例设计模式：

- 确保一个类只有一个对象
- 写法：
  - 把类的构造器私有
  - 定义一个类变量记住类的一个对象
  - 定义一个类方法，返回对象
  - ![image-20231117154900565](https://gitee.com/coi4/test/raw/master/img/image-20231117154900565.png)
- 实现方式：
  - 饿汉式单例：拿对象时，对象早就创建好（如上图）
  - 懒汉式单例：拿对象时，才开始创建对象（用类的对象时才创建对象）（延迟加载对象）
    - 把类的构造器私有
    - 定义一个类变量用于存储对象
    - 提供一个类方法，保证返回的是同一个对象
    - ![image-20231122084332687](https://gitee.com/coi4/test/raw/master/img/image-20231122084332687.png)
- 好处：任务管理器对象，获取运行时对象；在这些业务场景下，使用单例模式，可以避免浪费内存

### 2、继承

三大特征之二

#### 2.1、快速入门

关键字：extends（让一个类和另一个类建立起父子关系）![image-20231122084637833](https://gitee.com/coi4/test/raw/master/img/image-20231122084637833.png)

特点：子类能继承父类的**非私有成员**（成员变量、成员方法）

继承后对象的创建：子类的对象是由子类、父类共同完成的

执行原理：子类对象实际是由子父类两张设计图共同创建出来的![image-20231122085048143](https://gitee.com/coi4/test/raw/master/img/image-20231122085048143.png)

![image-20231122085109628](https://gitee.com/coi4/test/raw/master/img/image-20231122085109628.png)

对象能直接访问什么成员，是由子父类这多张设计图共同决定的，这多张设计图对外暴露了什么成员，对象就可以访问什么成员

好处：减少重复代码的编写，提高代码复用性![image-20231122085359580](https://gitee.com/coi4/test/raw/master/img/image-20231122085359580.png)

#### 2.2、注意事项

声明不变，重新实现

- 权限修饰符：限制类中的成员（成员变量、方法、构造器、代码块.....）能被访问的范围
  - private：只能本类
  - 缺省：本类、同一个包中的类
  - protected：本类，同一个包中的类、子孙类中
  - public：任意位置
  - ![image-20231122085812436](https://gitee.com/coi4/test/raw/master/img/image-20231122085812436.png)
  - private<缺省<protected<public
- 单继承、object类：Java是**单继承**的，Java中的类不支持多继承，但是**支持多层继承**；
  - Object类：Java所有类的祖宗类
- 方法重写：当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，覆盖父类的方法。
  - 重写后，方法的访问，Java会遵循就近原则
  - 使用Override注解，可以指定Java编译器，检查我们方法重写的格式是否正确，代码可读性也会更好
  - 子类重写父类方法，访问权限必须大于或等于父类该方法的权限
  - 重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小
  - 私有方法、静态方法不能被重写，报错
  - 应用场景之一：子类重写Object类的toSpring（）方法（直接调用返回对象地址），以便返回对象的内容（属性值）
- 子类中访问其他成员的特点：就近原则
  - 先子类局部范围找，然后子类成员范围找，最后父类成员范围找，如果父类范围还没有找到则报错
  - 如果子父类中，出现了重名的成员，优先使用子类的，非要在子类中用父类的——super关键字，指定访问父类的成员：super.父类成员变量/父类成员方法
- 子类构造器的特点：子类的全部构造器，都会**先调用父类的构造器**，在执行自己
  - 子类如何调用父类构造器：默认情况下，子类全部构造器的第一行代码都是super（），会调用父类的无参构造器；**如果父类没有无参数构造器，必须在子类构造器第一行手写super（.....）**，指定去调用父类的有参数构造器
  - 应用场景：子类构造器可以通过调用父类构造器，把对象中包含父类这部分的先初始化赋值，再回来把对象里包含子类这部分的数据也进行初始化赋值（为父类这部分成员变量进行初始化赋值）![image-20231122092548905](https://gitee.com/coi4/test/raw/master/img/image-20231122092548905.png)
  - this（....）调用兄弟构造器：任意类的构造器中，可以通过this（...）去调用该类的其他构造器![image-20231122092839050](https://gitee.com/coi4/test/raw/master/img/image-20231122092839050.png)
    - this（...）、super（...）都只能放在构造器的第一行，因此有了this就不能写super，反之亦然。

this：代表本类对象的引用；super：代表父类存储空间的标识![image-20231122093127092](https://gitee.com/coi4/test/raw/master/img/image-20231122093127092.png)

### 3、多态

三大特征之三（封装、继承、多态）

多态是在继承/实现情况下的一种现象，表现为：**对象**多态、**行为**多态

![image-20231122093839994](https://gitee.com/coi4/test/raw/master/img/image-20231122093839994.png)

前提：有**继承/实现**关系；存在父类引用子类对象；存在**方法重写**

成员特点：

- 成员变量：编译运行看左边
- 成员方法：编译看左边，运行看右边（调用的是重写后的方法）

注意事项：Java中的属性（成员变量）不谈多态

好处：右边对象是解耦合的，便于扩展和维护（定义方法时，使用父类类型作为形参，可以接受一切子类对象，扩展性更强）

多态下不能使用子类的独有功能，解决方案：

- 类型转化（父类变量转换为子类类型）：

  - 自动类型转换（使用父类的功能就能完成相应的操作）（向下转型）：父类 变量名=new 子类![image-20231122094424657](https://gitee.com/coi4/test/raw/master/img/image-20231122094424657.png)

  - 强制类型转换（向上转型）：子类 变量名=（子类）父类变量![image-20231122094434683](https://gitee.com/coi4/test/raw/master/img/image-20231122094434683.png)

    ```
    //如果p接收的是子类对象
    if(父类 instance 子类){
    //将p转换为子类类型
    子类 变量名=（子类）父类变量；
    }
    ```

    

  - 注意事项：原本是什么类型，才能还原成什么类型

    - 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错

    - 运行时，发现对象的真实类型与强转后的类型不同，会报类型转换异常（ClassCastException）的错误![image-20231122094752134](https://gitee.com/coi4/test/raw/master/img/image-20231122094752134.png)

    - 强转前，建议使用instanceof关键字，判断当前对象的真是类型，再进行强转![image-20231122094849504](https://gitee.com/coi4/test/raw/master/img/image-20231122094849504.png)

      ```
      Fu f1=new Zi();
      Fu f2=new Son();
      if(f1 instanceof Zi){
         System.out.println("f1是Zi的类型")
      }
      ```

### 4、final

可以修饰类、方法、变量

修饰类：最终类——不能被继承了

修饰方法：最终方法——不能被重写了

修饰变量：只能被赋值一次

注意事项：

- 修饰基本类型的变量，变量存储的数据不能被改变
- 修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向的对象的内容可以被改变

常量：使用了static final 修饰的成员变量；通常用于记录系统的配置信息

常量名的命名规范：建议使用大写字母；多个单词用下划线链接

程序编译后，常量会被宏替换：出现常量的地方全部会被替换成其记住的字面量，保证使用常量和直接用字面量的性能一样

![image-20231124141015743](https://gitee.com/coi4/test/raw/master/img/image-20231124141015743.png)

### 5、抽象类

abstract，修饰类，成员方法

修饰类——抽象类

修饰方法——抽象方法，不能有方法体

抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类

主要特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现

一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类

场景和好处：多个类中只要有重复代码（包括相同的方法签名），我们都应该抽取到父类中，此时，父类中就有可能存在只有方法签名的方法，这时，父类必定是抽象类，抽出这样的抽象类，就是为了更好的支持多态；不知道系统未来具体业务实现时，可以先定义抽象类，让子类去继承实现，以便扩展

![image-20231124141747065](https://gitee.com/coi4/test/raw/master/img/image-20231124141747065.png)

常见应用场景：模板方法设计模式

- 解决方法中存在重复代码的问题
- 写法：
  - 定义一个抽象类
  - 在里面定义两个方法
    - 模板方法：把相同代码放里面去
    - 抽象方法：具体实现交给子类完成
- 建议用final关键字修饰模板方法
  - 模板方法给对象直接使用，不能被子类重写
  - 一旦重写，方法失效

案例：

![image-20231124142222941](https://gitee.com/coi4/test/raw/master/img/image-20231124142222941.png)

- 定义一个抽象类
- 定义两个方法
- 定义子类继承抽象类，重写抽象方法
- 创建子类对象，调用模板方法完成功能

### 6、接口

interface，定义出一个特殊结构：接口

![image-20231124142447245](https://gitee.com/coi4/test/raw/master/img/image-20231124142447245.png)

接口是用来被类实现（implements）的，实现接口的类被称为实现类

![image-20231124142541479](https://gitee.com/coi4/test/raw/master/img/image-20231124142541479.png)

实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类

好处：

- 弥补了类单继承的不足，类可以同时实现多个接口（通过接口，可以让一个类有一个亲爹的同时，还可以找多个干爹去扩展自己的功能）
- 通过接口去找干爹，别人通过你implements的接口，就可以显性的知道你是谁，从而也就可以放心地把你当作谁来用

- 让程序可以面向接口编程，这样既不用关心实现的细节，也可以灵活方便的切换各种实现

案例：

班级学生信息管理模块的开发

![image-20231124143444709](https://gitee.com/coi4/test/raw/master/img/image-20231124143444709.png)

jdk8后接口新增三种形式的方法：

![image-20231124143526362](https://gitee.com/coi4/test/raw/master/img/image-20231124143526362.png)

- 默认方法：使用default修饰，使用实现类的对象调用
- 静态方法：static修饰，必须用当前接口名调用
- 私有方法：private修饰，只能在接口内部被调用
- 默认被public修饰

便于扩展与维护

接口的多继承：一个接口可以同时继承多个接口，便于实现类去实现![image-20231124143839686](https://gitee.com/coi4/test/raw/master/img/image-20231124143839686.png)

注意事项：

- 一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承
- 一个类实现多个接口，如果多个接口中存在方法签名冲突，此时不支持多实现
- 一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的
- 一个类实现了多个接口，多个接口中存在同名的默认方法；可以不冲突，这个类重写该方法即可

### 7、内部类

内部类：类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），**如果一个类定义在另一个类内部，这个类就成为内部类**

场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类

#### 7.1、成员内部类

类中的一个普通成员；JDK16之前，成员内部类中不能定义静态成员，后可以

格式：![image-20231201142351690](https://gitee.com/coi4/test/raw/master/img/image-20231201142351690.png)

成员内部类中访问其他成员特点：

- 可以直接访问外部类的实例成员、静态成员
- 可以拿到当前外部类对象，格式是：`外部类名.this`

#### 7.2、静态内部类

有static修饰的内部类，属于**外部类自己特有**

格式：![image-20231201142647050](https://gitee.com/coi4/test/raw/master/img/image-20231201142647050.png)

可以直接访问外部类的静态成员，不可以直接访问外部类的实例成员

#### 7.3、局部内部类

定义在方法中、代码块中、构造器等执行体中，很鸡肋！

#### 7.4、*匿名内部类

特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字

格式：![image-20231201142934003](https://gitee.com/coi4/test/raw/master/img/image-20231201142934003.png)

本质就是一个子类，并会立即创建出一个子类对象

用于更方便的创建一个子类对象

场景：

- 通常作为一个参数传输给方法：![image-20231201143143981](https://gitee.com/coi4/test/raw/master/img/image-20231201143143981.png)

  ![image-20231201143154396](https://gitee.com/coi4/test/raw/master/img/image-20231201143154396.png)

### 8、枚举

特殊类

格式：![image-20231208144213534](https://gitee.com/coi4/test/raw/master/img/image-20231208144213534.png)

注意：

- 第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开；
- 这些名称，本质上是常量，每一个常量都会记住枚举类的一个对象；
- 构造器都是私有的，对外不能创建对象
- 都是最终类，不可以被继承
- 从第二行开始，可以定义类的其他各种成员
- 枚举类都是继承java.lang.Enum类的，从enum类也会继承到一些方法

使用枚举类实现单例设计模式

应用场景：

- 用来表示一组信息，然后作为参数进行传输（选择定义一个一个变量表示一组信息，并作为参数传输）
- 参数值不受约束（定义枚举表示一组信息，并作为参数传输）
- 代码可读性好，参数值得到了约束，对使用者更友好

### 9、泛型

定义类，接口、方法时，同时声明了一个或者多个类型变量（如：`<E>`)，称为泛型类，泛型接口、泛型方法、统称泛型

![image-20231208150857021](https://gitee.com/coi4/test/raw/master/img/image-20231208150857021.png)

作用：提供了编译阶段约束所能操作的数据类型，并自动进行检查的能力，避免强制类型转换

本质：把具体的数据类型作为参数传给类型变量

泛型类：

- ![image-20231208151023491](https://gitee.com/coi4/test/raw/master/img/image-20231208151023491.png)

泛型接口：

- ![image-20231208151047038](https://gitee.com/coi4/test/raw/master/img/image-20231208151047038.png)

泛型方法：

- ![image-20231208151122331](https://gitee.com/coi4/test/raw/master/img/image-20231208151122331.png)
- ![image-20231208151151860](https://gitee.com/coi4/test/raw/master/img/image-20231208151151860.png)
- 通配符：？，可以在”使用泛型“时代表一切类型
- 泛型上下限
  - 上限：？extends Car：？能接收的必须是Car或其子类
  - 下限：？ super Car：？能接收的必须是Car或其父类

注意事项：

- 一旦程序编译成class文件，class文件中就不存在泛型（泛型擦除）
- 不支持基本数据类型，只支持对象类型（引用数据类型）

## 二、常用API

应用程序编程接口

### 1、API（一）

### 1.1、Object类

祖宗类

| 方法                              |                                      |
| --------------------------------- | ------------------------------------ |
| public String toString（）        | 返回对象的字符串表示                 |
| public boolean equals（Object o） | 判断两个对象是否相等                 |
| protected Object clone（）        | 对象克隆（返回一个一摸一样的新对象） |

toString（）方法存在的意义就是为了被子类重写，以便返回对象具体内容

equals存在的意义：被子类重写，以便子类自己来定制比较规则（比如比较对象内容）（直接比较两个对象的地址是否相同完全可以用==）

浅克隆：数据一模一样（引用类型拷贝的只是地址）

深克隆：对象中基本类型的数据直接拷贝；字符串拷贝的还是地址；对象中还包含其他对象，不会拷贝地址，会创建新对象（数组）

### 1.2、Objects

工具类，提供了很多操作对象的静态方法

Objects.equals(s1,s2)；

| 方法                                               |                              |
| -------------------------------------------------- | ---------------------------- |
| public static boolean equals（Object a，Object b） | 先做非空判断，再比较两个对象 |
| public static boolean isNull（Object obj）         | 判断是否非空，空返回true     |
| public static boolean nonNull（Object obj）        | 判断是否不为null             |

![image-20231208153450896](https://gitee.com/coi4/test/raw/master/img/image-20231208153450896.png)

### 1.3、包装类

把基本数据类型包装成对象

![image-20231208154031501](https://gitee.com/coi4/test/raw/master/img/image-20231208154031501.png)

![image-20231208154103615](https://gitee.com/coi4/test/raw/master/img/image-20231208154103615.png)

自动装箱：基本数据类型可以自动转换为包装类型

自动拆箱

可以把基本类型的数据转换成字符串类型：![image-20231208154217051](https://gitee.com/coi4/test/raw/master/img/image-20231208154217051.png)

String rs1=Integer.toString(23);

可以把字符串类型的数值转换成数值本身对应的数据类型：![image-20231208154302594](https://gitee.com/coi4/test/raw/master/img/image-20231208154302594.png)



### 1.4、StringBuilder、StringBuffer

### 1.5、StringJoiner

### 1.6、BigDecimal

### 2、API（二）

### 3、API（三）

#### 3.1、常见算法

#### 3.2、正则表达式

#### 3.3、异常

##### 3.3.1、认识异常

![image-20231201151346117](https://gitee.com/coi4/test/raw/master/img/image-20231201151346117.png)



> error：系统级别错误（严重错误），表示系统出现问题，sun公司自己用
>
> Exception：叫异常，代表程序异常，程序员通常会用Exception以及它的孩子来封装程序出现的问题
>
> - 运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（比如：数组索引越界异常）
> - 编译时异常：编译阶段就会出现错误提醒（比如：日期解析异常）

抛出异常（throws）

- 在方法上使用throws关键字，可以将方法内部出现的异常跑出去给调用者处理![image-20231201151839508](https://gitee.com/coi4/test/raw/master/img/image-20231201151839508.png)

捕获异常（try...catch)：

- 直接捕获程序出现的异常![image-20231201151937657](https://gitee.com/coi4/test/raw/master/img/image-20231201151937657.png)

用来查找bug；可以作为方法内部的特殊返回值，通知上层调用者底层的执行情况

##### 3.3.2、自定义异常

企业自己的某种问题，想通过异常来表示，以便用异常来管理该问题，就需要自己来定义异常类

种类：

- 自定义运行时异常：![image-20231201152405530](https://gitee.com/coi4/test/raw/master/img/image-20231201152405530.png)
- 自定义编译时异常：![image-20231201152413302](https://gitee.com/coi4/test/raw/master/img/image-20231201152413302.png)

异常有什么作用：

1. 用来查询系统Bug的关键参考信息
2. 可以作为方法内部的一种特殊返回值，以便通知上层调用者底层的执行情况

##### 3.3.3、异常的处理

捕获异常，记录异常并响应合适的信息给用户

捕获异常，尝试重新修复

**底层的异常抛出去给最外层，最外层集中捕获处理**

抛出异常（throws）

- 在方法上使用throws关键字，可以将方法内部出现的异常跑出去给调用者处理![image-20231201152844738](https://gitee.com/coi4/test/raw/master/img/image-20231201152844738.png)

捕获异常（try...catch）

- 直接捕获程序出现的异常![image-20231201152941489](https://gitee.com/coi4/test/raw/master/img/image-20231201152941489.png)



### 3、集合(java.util)

#### 3.1、collection集合

#### 3.2、map集合

* 双列集合，也叫键值对集合
* 每个元素“ key=value” 称为一个键值对 / 键值对对象 / 一个 Entry 对象
* 所有**键是不允许重复**的，但值可以重复
* 运用场景：**需要存储一一对应数据时**，可以考虑

##### 3.2.1.、map常用方法

| 方法名                       | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| .put(K key,V value)          | **添加**元素(map.put("手表"，100))                           |
| .size()                      | 获取集合**大小**                                             |
| .clear()                     | **清空**集合                                                 |
| .isEmpty()                   | 判断集合**是否为空**，为空返回 true , 反之                   |
| .get(Object key)             | 根据键**获取对应值**（map.get("手表")                        |
| .remove(Object key)          | 根据键**删除整个元素**( 返回键的值)(map.remove( "手表 "))    |
| .containsKey(Object key)     | 判断**是否包含某个键**(返回ture/false)                       |
| .containsValue(Object value) | 判断**是否包含某个值**(map.containsValue(100))               |
| Set<K> keySet()              | **获取全部键**的集合(Set<String> keys=map.keySet();)         |
| Collection<V> values()       | **获取**Map集合的**全部值**(Collection<Integer) values=map.values();) |
| .pulAll(Object)              | 把其他集合数据**倒入**自己集合中(map1.putAll(map2);)(map2集合倒入map1) |

##### 3.2.2、遍历方法

* 键找值

  ```java
  // 1、获取全部键
  Set<String> keys=map.keySet();
  
  // 2、遍历全部键，根据键获取对应值
  for(String key:keys){
      double value=map.get(key);
            System.out.println(key+"====>"+value);
  }
  
  ```

  

* 键值对（难度较大）

  ```java
  // 1、调用Map集合提供entrySet方法，把Map集合转换成键值对类型的Set集合
  Set<Map.Entry<String,Double>> entries=map.entrySet();
  
  for(Map.Entry<String,Double>entry:entries){
      String key=entry.getKey();
      double value=entry.getValue();
      System.out.println(key+"====>"+value);
  }
  ```

  

* Lambda（JDK8之后）（非常简单）

  ```java
  //遍历map集合，传递Lambda表达式
  map.forEach((k,v)->{
      System.out.println(k+"---->"+v);
  });
  ```

  

##### 3.2.3、HashMap

* 用的最多

* 无序、不重复（后面重复的数据（值）会覆盖前面的数据）、无索引

* 跟HashSet底层原理一样，基于哈希表实现（原来学的 Set 系列集合的底层就是基于 Map 实现的，只是 Set 集合中的元素只要键数据，不要值数据）（增删改查的性能都较好）

* **利用键计算哈希值**，与值无关

* 依赖 **hashCode** 方法和 **equals** 方法保证键的唯一

* 如果键要存储的是自定义对象，需要重写 hashCode 和 equals 方法

* ```java
  Map<String, Integer> map = new HashMap<>() ;
  ```

  

##### 3.2.4、LinkedHashMap

* 有序（存储和取出顺序一样）、不重复、无索引

* 底层原理跟LinkedHashSet一样为哈希表+双链表（保证有序）

* ```java
  Map<String, Integer> map = new LinkedHashMap<>();
  ```

##### 3.2.5、TreeMap

* **按照键**大小默认升序排序、不重复、无索引

* 跟TreeSet一样基于红黑树实现

* 同样支持两种方式指定排序顺序

* ```java
  //第一步：先让Student类，实现Comparable接口
  public class Student implements Comparable<Student>{
      private String name;
      private int age;
      private double height;
  	//无参数构造方法
      public Student(){}
      //全参数构造方法
      public Student(String name, int age, double height){
          this.name=name;
          this.age=age;
          this.height=height;
      }
      //...get、set、toString()方法自己补上..
      
      //按照年龄进行比较，只需要在方法中让this.age和o.age相减就可以。
      /*
      原理：
      在往TreeSet集合中添加元素时，add方法底层会调用compareTo方法，根据该方法的
      结果是正数、负数、还是零，决定元素放在后面、前面还是不存。
      */
      @Override
      public int compareTo(Student o) {
          //this：表示将要添加进去的Student对象
          //o: 表示集合中已有的Student对象
          return this.age-o.age;
      }
  }
  
  ```

* ```java
  /**
   * 目标：掌握TreeMap集合的使用。
   */
  public class Test3TreeMap {
      public static void main(String[] args) {
          Map<Student, String> map = new TreeMap<>(new Comparator<Student>() {
              @Override
              public int compare(Student o1, Student o2) {
                  return Double.compare(o1.getHeight(), o2.getHeight());
              }
          });
  //        Map<Student, String> map = new TreeMap<>(( o1,  o2) ->   Double.compare(o2.getHeight(), o1.getHeight()));
          map.put(new Student("蜘蛛精", 25, 168.5), "盘丝洞");
          map.put(new Student("蜘蛛精", 25, 168.5), "水帘洞");
          map.put(new Student("至尊宝", 23, 163.5), "水帘洞");
          map.put(new Student("牛魔王", 28, 183.5), "牛头山");
          System.out.println(map);
      }
  }
  ```

  

##### 3.2.6、案例合集

1. 统计投票人数

   > 某个班级 80 名学生，现在需要组织秋游活动，班长提供了四个景点依次是（ A 、 B 、 C 、 D ） ,
   > 每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。

   ```java
   // 1、把80个学生选择的景点数据拿到程序中来。
           List<String> data = new ArrayList<>();
           String[] selects = {"A", "B", "C", "D"};
           Random r = new Random();
           for (int i = 1; i <= 80; i++) {
               // 每次模拟一个学生选择一个景点，存入到集合中去。
               int index = r.nextInt(4); // 0 1 2 3
               data.add(selects[index]);
           }
           System.out.println(data);
   
           // 2、开始统计每个景点的投票人数
           // 准备一个Map集合用于统计最终的结果
           Map<String, Integer> result = new HashMap<>();
   
           // 3、开始遍历80个景点数据
           for (String s : data) {
               // 问问Map集合中是否存在该景点
               if(result.containsKey(s)){
                   // 说明这个景点之前统计过。其值+1. 存入到Map集合中去
                   result.put(s, result.get(s) + 1);
               }else {
                   // 说明这个景点是第一次统计，存入"景点=1"
                   result.put(s, 1);
               }
           }
           System.out.println(result);
       }
   }
   
   ```

2. HashMap集合存储自定义对象并遍历

   > 创建一个HashMap集合，键是学生对象（Student），值是籍贯（String），存储三个键值对元素，并遍历

   ```java
   public class Student implements Comparable<Student> {
       private String name;
       private int age;
       private double height;
   
       // this  o
       @Override
       public int compareTo(Student o) {
           return this.age - o.age; // 年龄升序排序
       }
   
       @Override
       public boolean equals(Object o) {
           if (this == o) return true;
           if (o == null || getClass() != o.getClass()) return false;
           Student student = (Student) o;
           return age == student.age && Double.compare(student.height, height) == 0 && Objects.equals(name, student.name);
       }
   
       @Override
       public int hashCode() {
           return Objects.hash(name, age, height);
       }
   
       public Student() {
       }
   
       public Student(String name, int age, double height) {
           this.name = name;
           this.age = age;
           this.height = height;
       }
   
   	//...get,set方法自己补全....
   
       @Override
       public String toString() {
           return "Student{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   ", height=" + height +
                   '}';
       }
   }
   ```

   ```java
   /**
    * 目标：掌握Map集合下的实现类：HashMap集合的底层原理。
    */
   public class Test1HashMap {
       public static void main(String[] args) {
           Map<Student, String> map = new HashMap<>();
           map.put(new Student("蜘蛛精", 25, 168.5), "盘丝洞");
           map.put(new Student("蜘蛛精", 25, 168.5), "水帘洞");
           map.put(new Student("至尊宝", 23, 163.5), "水帘洞");
           map.put(new Student("牛魔王", 28, 183.5), "牛头山");
           System.out.println(map);
       }
   }
   
   ```

3. TreeMap练习

   > 创建一个TreeMap集合，键是学生对象（Student），值是籍贯（String）。学生属性姓名和年龄，按照年龄进行排序并遍历

4. 集合嵌套

   > 

```java
/**
 * 目标：理解集合的嵌套。
 * 江苏省 = "南京市","扬州市","苏州市“,"无锡市","常州市"
 * 湖北省 = "武汉市","孝感市","十堰市","宜昌市","鄂州市"
 * 河北省 = "石家庄市","唐山市", "邢台市", "保定市", "张家口市"
 */
public class Test {
    public static void main(String[] args) {
        // 1、定义一个Map集合存储全部的省份信息，和其对应的城市信息。
        Map<String, List<String>> map = new HashMap<>();

        List<String> cities1 = new ArrayList<>();
        Collections.addAll(cities1, "南京市","扬州市","苏州市" ,"无锡市","常州市");
        map.put("江苏省", cities1);

        List<String> cities2 = new ArrayList<>();
        Collections.addAll(cities2, "武汉市","孝感市","十堰市","宜昌市","鄂州市");
        map.put("湖北省", cities2);

        List<String> cities3 = new ArrayList<>();
        Collections.addAll(cities3, "石家庄市","唐山市", "邢台市", "保定市", "张家口市");
        map.put("河北省", cities3);
        System.out.println(map);

        List<String> cities = map.get("湖北省");
        for (String city : cities) {
            System.out.println(city);
        }

        map.forEach((p, c) -> {
            System.out.println(p + "----->" + c);
        });
    }
}

```

#### 3.3、Stream流

简化集合、数组操作的 API 。结合了 Lambda 表达式

* 先**得到**集合或者数组的 Stream 流。
* 然后**调用** Stream 流的**方法**对数据进行处理。
* **获取**处理的**结果**。

示例：

> 有一个List集合，元素有"张三丰","张无忌","周芷若","赵敏","张强"，找出姓张，且是3个字的名字，存入到一个新集合中去。

```java
// 找出姓张，且是3个字的名字，存入到一个新集合中去。
List<String> list = new ArrayList<>();
for (String name : names) {
    if(name.startsWith("张") && name.length() == 3){
        list.add(name);
    }
}
System.out.println(list);

```

```java
List<String> list2 = names.stream().filter(s -> s.startsWith("张")).filter(a -> a.length()==3).collect(Collectors.toList());
System.out.println(list2);

```

##### 3.3.1、Stream流常用方法

###### 3.3.1.1、获取Stream流

- 获取集合的

  - List集合的

    - Stream<E> stream()

    - > 找出姓张，且是3个字的名字，存入到一个新的集合

    - ```java
      List<String> names = new ArrayList<>();
              Collections.addAll(names, "张三丰","张无忌","周芷若","赵敏","张强");
              Stream<String> stream = names.stream();
      
      ```

  - Set集合的

    - Stream<E> stream()

    - ```java
      Set<String> set = new HashSet<>();
              Collections.addAll(set, "刘德华","张曼玉","蜘蛛精","马德","德玛西亚");
              Stream<String> stream1 = set.stream();
              stream1.filter(s -> s.contains("德")).forEach(s -> System.out.println(s));
      //filter():过滤Stream流，包含德才能留下
      
      ```

      

  - Map集合的

    - Stream方法是collection提供，map集合不属于collection，不可以直接调用

    - ```java
      Map<String, Double> map = new HashMap<>();
              map.put("古力娜扎", 172.3);
              map.put("迪丽热巴", 168.3);
              map.put("马尔扎哈", 166.3);
              map.put("卡尔扎巴", 168.3);
      
              Set<String> keys = map.keySet();
              Stream<String> ks = keys.stream();
      
              Collection<Double> values = map.values();
              Stream<Double> vs = values.stream();
      //values.stream()回车
              Set<Map.Entry<String, Double>> entries = map.entrySet();
              Stream<Map.Entry<String, Double>> kvs = entries.stream();
      //整体处理
              kvs.filter(e -> e.getKey().contains("巴"))
                      .forEach(e -> System.out.println(e.getKey()+ "-->" + e.getValue()));
      //键包含巴
      
      ```

      

- 获取数组的

  - ```java
    String[] names2 = {"张翠山", "东方不败", "唐大山", "独孤求败"};
    //方法1 Arrays类
            Stream<String> s1 = Arrays.stream(names2);
    //方法2 Stream类
            Stream<String> s2 = Stream.of(names2);
        }
    }
    
    ```

###### 3.3.1.2、中间方法

调用完成后会返回新的 Stream 流，可以继续使用 ( 支持链式编程 ) 。

| Stream提供的常用中间方法                                  | 说明                                        |
| --------------------------------------------------------- | ------------------------------------------- |
| Stream<T> filter(Predicate<? super T>predicate)           | 流中的数据进行过滤(xx.stream().filter(s->)) |
| Stream(T) sourted()                                       | 对元素进行升序排序                          |
| Stream(T) sorted(Comparator<? super T> comparator)        | 按照指定规则排序                            |
| Stream(T) limit(long maxSize)                             | 获取前几个元素                              |
| Stream(T) skip(long n)                                    | 跳过前几个元素                              |
| Stream(T) distinct()                                      | 去除流中重复的元素。                        |
| <R> Stream<R> map(Function<? super T,? extends R> mapper) | 对元素进行加工，并返回对应的新流            |
| static <T> Stream<T> concat(Stream a, Stream b)           | 合并 a 和 b 两个流为一个流                  |

 示例：

```java
/**
 * 目标：掌握Stream流提供的常见中间方法。
 */
public class StreamTest3 {
    public static void main(String[] args) {
        List<Double> scores = new ArrayList<>();
        Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0);
        // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。
        scores.stream().filter(s -> s >= 60).sorted().forEach(s -> System.out.println(s));

        List<Student> students = new ArrayList<>();
        Student s1 = new Student("蜘蛛精", 26, 172.5);
        Student s2 = new Student("蜘蛛精", 26, 172.5);
        Student s3 = new Student("紫霞", 23, 167.6);
        Student s4 = new Student("白晶晶", 25, 169.0);
        Student s5 = new Student("牛魔王", 35, 183.3);
        Student s6 = new Student("牛夫人", 34, 168.5);
        Collections.addAll(students, s1, s2, s3, s4, s5, s6);
        // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.
        students.stream().filter(s -> s.getAge() >= 23 && s.getAge() <= 30)
                .sorted((o1, o2) -> o2.getAge() - o1.getAge())
                .forEach(s -> System.out.println(s));

        // 需求3：取出身高最高的前3名学生，并输出。
        students.stream().sorted((o1, o2) -> Double.compare(o2.getHeight(), o1.getHeight()))
                .limit(3).forEach(System.out::println);
        System.out.println("-----------------------------------------------");

        // 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6
        students.stream().sorted((o1, o2) -> Double.compare(o2.getHeight(), o1.getHeight()))
                .skip(students.size() - 2).forEach(System.out::println);

        // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。
        students.stream().filter(s -> s.getHeight() > 168).map(Student::getName)
               .distinct().forEach(System.out::println);

        // distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）
        students.stream().filter(s -> s.getHeight() > 168)
                .distinct().forEach(System.out::println);

        Stream<String> st1 = Stream.of("张三", "李四");
        Stream<String> st2 = Stream.of("张三2", "李四2", "王五");
        Stream<String> allSt = Stream.concat(st1, st2);
        allSt.forEach(System.out::println);
    }
}

```

###### 3.3.1.3、终结方法

调用完成后，不会返回新 Stream 了，没法继续使用流了

| Stream提供的常用终结方法                          | 说明                                     |
| ------------------------------------------------- | ---------------------------------------- |
| void forEach（                                    | 遍历                                     |
| long count()                                      | 统计此流运算后的元素个数                 |
| Optional<T> max(Comparator<? super T> comparator) | 获取此流运算后的最大值元素               |
| Optional<T> min(Comparator<? super T> comparator) | 获取此流运算后的最小值元素               |
| R collect(Collector collector)                    | 把流处理后的结果收集到一个指定的集合中去 |
| Object[ ] toArracy                                | 把流处理后的结果收集到一个数组中去       |

| Collectors工具类提供了具体的收集方式                         | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| public static <T> Collector toList ()                        | 把元素收集到 List 集合中 |
| public static <T> Collector toSet ()                         | 把元素收集到 Set集合中   |
| public static Collector toMap (Function keyMapper , Function valueMapper) | 把元素收集到 map集合中   |

示例：

```java
/**
 * 目标：Stream流的终结方法
 */
public class StreamTest4 {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        Student s1 = new Student("蜘蛛精", 26, 172.5);
        Student s2 = new Student("蜘蛛精", 26, 172.5);
        Student s3 = new Student("紫霞", 23, 167.6);
        Student s4 = new Student("白晶晶", 25, 169.0);
        Student s5 = new Student("牛魔王", 35, 183.3);
        Student s6 = new Student("牛夫人", 34, 168.5);
        Collections.addAll(students, s1, s2, s3, s4, s5, s6);
        // 需求1：请计算出身高超过168的学生有几人。
        long size = students.stream().filter(s -> s.getHeight() > 168).count();
        System.out.println(size);

        // 需求2：请找出身高最高的学生对象，并输出。
        Student s = students.stream().max((o1, o2) -> Double.compare(o1.getHeight(), o2.getHeight())).get();
        System.out.println(s);

        // 需求3：请找出身高最矮的学生对象，并输出。
        Student ss = students.stream().min((o1, o2) -> Double.compare(o1.getHeight(), o2.getHeight())).get();
        System.out.println(ss);

        // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。
        // 流只能收集一次。
        List<Student> students1 = students.stream().filter(a -> a.getHeight() > 170).collect(Collectors.toList());
        System.out.println(students1);

        Set<Student> students2 = students.stream().filter(a -> a.getHeight() > 170).collect(Collectors.toSet());
        System.out.println(students2);

        // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。
        Map<String, Double> map =
                students.stream().filter(a -> a.getHeight() > 170)
                        .distinct().collect(Collectors.toMap(a -> a.getName(), a -> a.getHeight()));
        System.out.println(map);

        // Object[] arr = students.stream().filter(a -> a.getHeight() > 170).toArray();
        Student[] arr = students.stream().filter(a -> a.getHeight() > 170).toArray(len -> new Student[len]);
        System.out.println(Arrays.toString(arr));
    }
}

```

### 4、io流（一）(java.io)

#### 4.1、File

存储数据的方案

* 变量
* 数组
* 对象
* 集合

断电、程序终止会丢失

* 文件是非常重要的存储方式，在计算机硬盘中。即便断电，或者程序终止了，存储在硬盘文件中的数据也不会丢失
* File是 java.io. 包下的类， File 类的对象，用于**代表当前操作系统的文件**（可以是文件、或文件夹）
* **File 类只能对文件本身进行操作，不能读写文件里面存储的数据**
* **File代表文本；Io流读写数据**

##### 4.1.1、创建对象

示例：

```Java
/**
 * 目标：掌握File创建对象，代表具体文件的方案。
 */
public class FileTest1 {
    public static void main(String[] args) {
        // 1、创建一个File对象，指代某个具体的文件。
        // 路径分隔符
        // File f1 = new File("D:/resource/ab.txt");
        // File f1 = new File("D:\\resource\\ab.txt");
        File f1 = new File("D:" + File.separator +"resource" + File.separator + "ab.txt");
        System.out.println(f1.length()); // 文件大小。字节个数

        File f2 = new File("D:/resource");
        System.out.println(f2.length());

        // 注意：File对象可以指代一个不存在的文件路径
        File f3 = new File("D:/resource/aaaa.txt");
        System.out.println(f3.length());
        System.out.println(f3.exists()); // false

        // 我现在要定位的文件是在模块中，应该怎么定位呢？
        // 绝对路径：带盘符的
        // File f4 = new File("D:\\code\\javasepromax\\file-io-app\\src\\itheima.txt");
        // 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。
        File f4 = new File("file-io-app\\src\\itheima.txt");
        //（重要）
        System.out.println(f4.length());
    }
}

```



##### 4.1.2、常用方法

###### 4.2.2.1、判断文件类型、获取文件信息

| 方法名称                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public boolean exists()         | 判断当前文件对象，对应的文件路径是否存在，存在返回 true      |
| public boolean isFile()         | 判断前文件对象指代的是否是文件，是文件返回 true ，反之       |
| public boolean isDirectory()    | 判断当前文件对象指代的是否是文件夹，是文件夹返回 true ，反之 |
| public String getName()         | 获取文件的名称（包含后缀）                                   |
| public long length()            | 获取文件的大小，返回字节个数                                 |
| public long lastModified()      | 获取文件的最后修改时间                                       |
| public String getPath()         | 获取创建文件对象时，使用的路径                               |
| public String getAbsolutePath() | 获取绝对路径                                                 |

示例：

```java
File f1 = new File("D:/resource/ab.txt");

// 5.public String getName()：获取文件的名称（包含后缀）
System.out.println(f1.getName());

// 6.public long length()：获取文件的大小，返回字节个数
System.out.println(f1.length());

// 7.public long lastModified()：获取文件的最后修改时间。
long time = f1.lastModified();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
System.out.println(sdf.format(time));

// 8.public String getPath()：获取创建文件对象时，使用的路径
File f2 = new File("D:\\resource\\ab.txt");
File f3 = new File("file-io-app\\src\\itheima.txt");
System.out.println(f2.getPath());
System.out.println(f3.getPath());

// 9.public String getAbsolutePath()：获取绝对路径
System.out.println(f2.getAbsolutePath());
System.out.println(f3.getAbsolutePath());

```

###### 4.2.2.2、创建文件、删除文件

| 方法名                         | 说明                 |
| ------------------------------ | -------------------- |
| public boolean createNewFile() | 创建一个新的空的文件 |
| public boolean mkdir()         | 只能创建一级文件夹   |
| public boolean mkdirs()        | 可以创建多级文件夹   |
| public boolean delete()        | 删除文件、空文件夹   |

示例：

```java
/**
 * 目标：掌握File创建和删除文件相关的方法。
 */
public class FileTest3 {
    public static void main(String[] args) throws Exception {
        // 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。
        File f1 = new File("D:/resource/itheima2.txt");
        System.out.println(f1.createNewFile());

        // 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹
        File f2 = new File("D:/resource/aaa");
        System.out.println(f2.mkdir());

        // 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹
        File f3 = new File("D:/resource/bbb/ccc/ddd/eee/fff/ggg");
        System.out.println(f3.mkdirs());

        // 3、public boolean delete()：删除文件，或者空文件夹，注意：不能删除非空文件夹。删除后的文件不会进入回收站
        System.out.println(f1.delete());
        System.out.println(f2.delete());
        File f4 = new File("D:/resource");
        System.out.println(f4.delete());
    }
}

```



###### 4.2.2.3、遍历文件夹

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| public String[] list()    | 获取当前目录下所有的 " 一级文件名称 " 到一个**字符串数组**中去返回 |
| public File[] listFiles() | 获取当前目录下所有的 " 一级文件对象 " 到一个**文件对象数组**中去返回（重点） |

示例：

```java
/**
 * 目标：掌握File提供的遍历文件夹的方法。
 */
public class FileTest4 {
    public static void main(String[] args) {
        // 1、public String[] list()：获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。
        File f1 = new File("D:\\course\\待研发内容");
        String[] names = f1.list();
        for (String name : names) {
            System.out.println(name);
        }

        // 2、public File[] listFiles():（重点）获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点）
        File[] files = f1.listFiles();
        for (File file : files) {
            System.out.println(file.getAbsolutePath());
        }

        File f = new File("D:/resource/aaa");
        File[] files1 = f.listFiles();
        System.out.println(Arrays.toString(files1));
    }
}

```

1. 当主调是文件时，或者路径不存在时，返回null
2. 当主调是空文件夹时，返回一个长度为0的数组
3. **当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回**
4. 当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件
5. 当主调是一个文件夹，但是没有权限访问时，返回null

#### 4.2、递归（多级处理文件）

直接递归；间接递归

递归算法三要素：

* 递归的公式： f(n) = f(n-1) * n;
* 递归的终结点： f(1)
* 递归的方向必须走向终结点：![image-20231011235638120](https://gitee.com/coi4/test/raw/master/img/image-20231011235638120.png)

##### 4.2.1、案例

1. 计算n的阶乘

   > 计算 n 的阶乘， 5 的阶乘 =1*2*3*4*5; 6 的阶乘 =1*2*3*4*5*6 

   ```java
   /**
    * 目标：掌握递归的应用，执行流程和算法思想。
    */
   public class RecursionTest2 {
       public static void main(String[] args) {
           System.out.println("5的阶乘是：" + f(5));
       }
   
       //求n个数的阶乘
       public static int f(int n){
           // 终结点
           if(n == 1){
               return 1;
           }else {
               return f(n - 1) * n;
           }
       }
   }
   ```

   

2. 递归求1-n的和

   分析 : 我们先从数学思维上理解递归的流程和核心点
   ① 假如我们认为存在一个公式是 f(n) = 1 + 2 + 3 + 4 + 5 + 6 + 7 + ...(n-1) + n;
   ② 那么公式等价形式就是： f(n) = f(n-1) + n
   ③ 递归的终结点： f(1) = 1
   ④ 递归的方向

3. 猴子吃桃问题

   > 猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个
   > 第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个
   > 以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个
   > 等到第 10 天的时候发现桃子只有 1 个了。
   > 需求：请问猴子第一天摘了多少个桃子？

   分析：
   ① 整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：
   ② 递归公式：
   ③ 递归终结点：
   ④ 递归方向：

4. 文件搜索

   > 从 D: 盘中，搜索“ QQ.exe” 这个文件，找到后直接输出其位置。

   ```java
   /**
    * 目标：掌握文件搜索的实现。
    */
   public class RecursionTest3 {
       public static void main(String[] args) throws Exception {
             searchFile(new File("D:/") , "QQ.exe");
       }
   
       /**
        * 去目录下搜索某个文件
        * @param dir  目录
        * @param fileName 要搜索的文件名称
        */
       public static void searchFile(File dir, String fileName) throws Exception {
           // 1、把非法的情况都拦截住
           if(dir == null || !dir.exists() || dir.isFile()){
               return; // 代表无法搜索
           }
   
           // 2、dir不是null,存在，一定是目录对象。
           // 获取当前目录下的全部一级文件对象。
           File[] files = dir.listFiles();
   
           // 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。
           if(files != null && files.length > 0){
               // 4、遍历全部一级文件对象。
               for (File f : files) {
                   // 5、判断文件是否是文件,还是文件夹
                   if(f.isFile()){
                       // 是文件，判断这个文件名是否是我们要找的
                       if(f.getName().contains(fileName)){
                           System.out.println("找到了：" + f.getAbsolutePath());
                           Runtime runtime = Runtime.getRuntime();
                           runtime.exec(f.getAbsolutePath());
                           //启动文件
                       }
                   }else {
                       // 是文件夹，继续重复这个过程（递归）
                       searchFile(f, fileName);
                   }
               }
           }
       }
   }
   
   ```

   

5. 啤酒问题

   > 啤酒 2 元 1 瓶， 4 个盖子可以换一瓶， 2 个空瓶可以换一瓶，
   > 请问 10 元钱可以喝多少瓶酒，剩余多少空瓶和盖子。15/3/1

```java


```

#### 4.3、字符集

##### 4.3.1、常见字符集

- ASCII 字符集：只有英文、数字、符号等，**占 1 个字节。**
- GBK 字符集：汉字占 2 个字节，英文、数字占 1 个字节。
- UTF-8 字符集：汉字占 3 个字节，英文、数字占 1 个字节。

编码时的字符集和解码时使用的必须一致，否则会出现字符乱码

英文，数字一般不会乱码，因为很多字符集都兼容了 ASCII 编码

##### 4.3.2、编码解码操作方法

编码：把**字符串**按照指定的字符集**转换为字节数组**
解码：把**字节数组**按照指定的字符集**转换为字符串**

| String提供了如下方法                     | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| byte[] getBytes()                        | 使用平台的默认字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |
| String(byte[]ytes)                       | 通过使用平台的默认字符集解码指定的字节数组来构造新的 String  |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String          |

示例：

```java
/**
 * 目标：掌握如何使用Java代码完成对字符的编码和解码。
 */
public class Test {
    public static void main(String[] args) throws Exception {
        // 1、编码
        String data = "a我b";
        byte[] bytes = data.getBytes(); // 默认是按照平台字符集（UTF-8）进行编码的。
        System.out.println(Arrays.toString(bytes));

        // 按照指定字符集进行编码。
        byte[] bytes1 = data.getBytes("GBK");
        System.out.println(Arrays.toString(bytes1));

        // 2、解码
        String s1 = new String(bytes); // 按照平台默认编码（UTF-8）解码
        System.out.println(s1);

        String s2 = new String(bytes1, "GBK");
        System.out.println(s2);
    }
}

```

### 5、io流（二）

### 6、特殊文件

#### 6.1、Properties文件

##### 6.1.1、操作

- 创建properties属性文件

* 用Properties读取属性文件

  1. **创建**properties**对象**

  2. 加载properties属性**文件**中键值对数据**到对象**中去(用字符集)

     - ```java
       .load(new FilerReader(""))
       ```

  3. 通过键**取值**

     - ```java
       .getProperty("键名")
       ```

  4. **获取键全部集合遍历并输出**

     ```
     properties.
     ```

  5. 

* 

#### 6.2、xml文件

用来存储复杂的数据结构，和数据关系

作为软件的配置文件

![image-20231012211300216](https://gitee.com/coi4/test/raw/master/img/image-20231012211300216.png)

##### 6.2.1、文件内书写格式

- 文件内第一行必须为

```
<?xml version="1.0" encoding="UTF-8" ?>

```

- 注释

  ```
  <!--    -->
  ```

- 特殊符号报错

  ```
  <![CDATA[内容。。。]]>
  //CD回车
  ```

- 根标签只能有一个

##### 6.2.2、读取文件数据

1. 准备工作

   - 下载dom4j框架（官网下最新版）；下载第一个核心文件jar即可
   - 项目中创建Directory文件夹，复制过来
   - jar文件右键，选Add as Library -> 点击 OK

2. 用dom4j解析xml，得到document对象，

   | 构造器/方法                                | 说明                                                         |
   | ------------------------------------------ | ------------------------------------------------------------ |
   | public SAXReader() public                  | 构建 Dom4J 的解析器对象                                      |
   | *Document **read**(String url)             | 把 XML 文件读成 Document 对象                                |
   | public Document read(InputStream<br/>is)   | 通过字节输入流读取 XML 文件                                  |
   | Element getRootElement()                   | 获取根元素对象                                               |
   | public String getName()                    | 得到元素名字                                                 |
   | public List<Element> elements()            | 得到当前元素下所有子元素                                     |
   | public List<Element> elements(String name) | 得到当前元素下指定名字的子元素返回集合                       |
   | public Element element(String name)        | 得到当前元素下指定名字的子元素 , 如果有很多名字相同的返回第一个 |
   | public String attributeValue(String name)  | 通过属性名直接得到属性值                                     |
   | public String elementText( 子元素名 )      | 得到指定名称的子元素的文本                                   |
   | public String getText()                    | 得到文本                                                     |

   

##### 6.2.3、把数据写到xml文件中去

用io流

```java
public class Dom4JTest2 {
    public static void main(String[] args) {
        // 1、使用一个StringBuilder对象来拼接XML格式的数据。
        StringBuilder sb = new StringBuilder();
        sb.append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n");
        sb.append("<book>\r\n");
        sb.append("\t<name>").append("从入门到跑路").append("</name>\r\n");
        sb.append("\t<author>").append("dlei").append("</author>\r\n");
        sb.append("\t<price>").append(999.99).append("</price>\r\n");
        sb.append("</book>");

        try (
                BufferedWriter bw = new BufferedWriter(new FileWriter("properties-xml-log-app/src/book.xml"));
                ){
            bw.write(sb.toString());
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

```

### 7、日志技术

* 通常就是一个文件，里面记录的是程序运行过程中的各种信息，可以永久存储
* 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改。

日志技术：

* 日志框架：Logback（Logback 是基于 slf4j 的日志规范实现的框架）
  * 要使用该框架，至少需要在项目中整合三个模块
    * slf4j-api：日志接口
    * logback-core：基础模块
    * logback-classic：功能模块
* 日志接口：slf4j

#### 7.1、快速入门

![image-20231012221946603](https://gitee.com/coi4/test/raw/master/img/image-20231012221946603.png)

#### 7.2、*设置日志级别

日志级别指的是**日志信息的类型**，用于**控制系统中哪些日志级别是可以输出的**，日志都会分级别，常见的日志级别如下（优先级依次升高）

| 日志级别 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trace    | 追踪，指明程序运行轨迹                                       |
| debug    | 调试，实际应用中一般将其作为最低级别，而 trace 则很少使用    |
| *info    | 输出重要的运行信息，数据连接、网络连接、 IO 操作等等，使用较多 |
| *warn    | 警告信息，可能会发生问题，使用较多                           |
| *error   | 错误信息 , 使用较多                                          |

![image-20231012223848578](https://gitee.com/coi4/test/raw/master/img/image-20231012223848578.png)

只有日志级别大于或等于该级别，才会被输出

```java
public class LogBackTest {
    // 创建一个Logger日志对象
    public static final Logger LOGGER = LoggerFactory.getLogger("LogBackTest");

    public static void main(String[] args) {
        //while (true) {
            try {
                LOGGER.info("chu法方法开始执行~~~");
                chu(10, 0);
                LOGGER.info("chu法方法执行成功~~~");
            } catch (Exception e) {
                LOGGER.error("chu法方法执行失败了，出现了bug~~~");
            }
        //}
    }

    public static void chu(int a, int b){
        LOGGER.debug("参数a:" + a);
        LOGGER.debug("参数b:" + b);
        int c = a / b;
        LOGGER.info("结果是：" + c);
    }
}

```

![屏幕截图 2023-10-12 224327](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-12%20224327.png)

![屏幕截图 2023-10-12 224351](https://gitee.com/coi4/test/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-12%20224351.png)

### 8、多线程(java.lang)

线程是一个程序内部的一条执行流程

多线程指从软硬件上实现的多条执行流程的技术

* 12306同时可以有多人一起进入购票，每个人互不影响；百度网盘可以同时下载或上传多个文件；

#### 8.1、线程创建方式

##### 8.1.1、方式一：继承Thread类

不利于功能拓展

![image-20231012225824454](https://gitee.com/coi4/test/raw/master/img/image-20231012225824454.png)

不要把主线程任务放在启动子线程之前

```java
public class MyThread extends Thread{
    // 2、必须重写Thread类的run方法
    @Override
    public void run() {
        // 描述线程的执行任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程MyThread输出：" + i);
        }
    }
}
```

```java
public class ThreadTest1 {
    // main方法是由一条默认的主线程负责执行。
    public static void main(String[] args) {
        // 3、创建MyThread线程类的对象代表一个线程
        Thread t = new MyThread();
        // 4、启动线程（自动执行run方法的）
        t.start(); 

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出：" + i);
        }
    }
}
```

![image-20231012230801218](https://gitee.com/coi4/test/raw/master/img/image-20231012230801218.png)

##### 8.1.2、方式二：实现Runnable接口

如果线程有执行结果不能直接返回

![image-20231012230856411](https://gitee.com/coi4/test/raw/master/img/image-20231012230856411.png)

```java
/**
 * 1、定义一个任务类，实现Runnable接口
 */
public class MyRunnable implements Runnable{
    // 2、重写runnable的run方法
    @Override
    public void run() {
        // 线程要执行的任务。
        for (int i = 1; i <= 5; i++) {
            System.out.println("子线程输出 ===》" + i);
        }
    }
}
```

```java
public class ThreadTest2 {
    public static void main(String[] args) {
        // 3、创建任务对象。
        Runnable target = new MyRunnable();
        // 4、把任务对象交给一个线程对象处理。
        //  public Thread(Runnable target)
        new Thread(target).start();

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出 ===》" + i);
        }
    }
}
```

```java
public class ThreadTest2_2 {
    public static void main(String[] args) {
        // 1、直接创建Runnable接口的匿名内部类形式（任务对象）
        Runnable target = new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程1输出：" + i);
                }
            }
        };
        new Thread(target).start();

        // 简化形式1：
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程2输出：" + i);
                }
            }
        }).start();

        // 简化形式2：
        new Thread(() -> {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("子线程3输出：" + i);
                }
        }).start();

        for (int i = 1; i <= 5; i++) {
            System.out.println("主线程main输出：" + i);
        }
    }
}

```

![img](https://gitee.com/coi4/test/raw/master/img/_807729572__b41ccd9f106189d24140b8bc222089d9_2064002851_Screenshot_20231012_231645_0_xg_0.jpg)

##### 8.1.3、方式三：实现Calloble接口

可以返回线程执行完毕后的结果

代码复杂

![image-20231012231749871](https://gitee.com/coi4/test/raw/master/img/image-20231012231749871.png)

```java
public class ThreadTest3 {
    public static void main(String[] args) throws Exception {
        // 3、创建一个Callable的对象
        Callable<String> call = new MyCallable(100);
        // 4、把Callable的对象封装成一个FutureTask对象（任务对象）
        // 未来任务对象的作用？
        // 1、是一个任务对象，实现了Runnable对象.
        // 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。
        FutureTask<String> f1  = new FutureTask<>(call);
        // 5、把任务对象交给一个Thread对象
        new Thread(f1).start();


        Callable<String> call2 = new MyCallable(200);
        FutureTask<String> f2  = new FutureTask<>(call2);
        new Thread(f2).start();


        // 6、获取线程执行完毕后返回的结果。
        // 注意：如果执行到这儿，假如上面的线程还没有执行完毕
        // 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。
        String rs = f1.get();
        System.out.println(rs);

        String rs2 = f2.get();
        System.out.println(rs2);
    }
}

```

#### 8.2、Thread常用方法

| 构造器/方法                                 | 说明                                            |
| ------------------------------------------- | ----------------------------------------------- |
| public Thread（String name）                | 可以为当前线程指定名称                          |
| *public Thread(Runnable target)             | 封装 Runnable 对象成为线程对象                  |
| public Thread(Runnable target, String name) | 封装 Runnable 对象成为线程对象，并指定线程名称  |
| public void run()                           | 线程的任务方法                                  |
| public void start()                         | 启动线程                                        |
| *public String getName()                    | 获取当前线程的名称，线程名称默认是 Thread- 索引 |
| *public void setName(String name)           | 为线程设置名称                                  |
| *public static Thread currentThread()       | 获取当前执行的线程对象                          |
| *public static void sleep(long time)        | 让当前执行的线程休眠多少毫秒后，再继续执行      |
| public final void join()...                 | 让调用当前这个方法的线程先执行完！              |

### 9、网络通信（Java.net)

网络编程：可以让设备中的程序与网络上其他设备中的程序进行**数据交互**（实现网络通信）

**java.net.*包**下提供了网络编程的解决方案

基本通信架构：

- cs架构（Client 客户端 /Server 服务端）
  - Client客户端需要程序员开发（微信）
- BS 架构 (Browser 浏览器 /Server
  服务端 )
  - Browser浏览器不需要程序员开发实现（ie、火狐、360）

无论哪个架构都必须依赖网络通信

#### 9.1、三要素

##### 9.1.1、IP地址

* 设备在网络中的地址，是唯一的标识
* 全称：互联网协议地址
* 两种形式：
  * IPv4：共123位
  * IPv6：分8段表示，每段每四位编码成一个十六进制位表示，数之间用冒号隔开
* 公网IP：是可以连接互联网的 IP 地址
* 内网 IP ：也叫局域网 IP ，只能组织机构内部使用；192.168开头的就是常见的局域网地址，范围为192.168.0.0-192.168.255.255
* 特殊IP地址：127.0.0.1、Iocalhost；代表本机IP，只会寻找当前所在的主机

常用命令：

- ipconfig：查看本机IP地址
- ping IP：检查网络是否连通

InetAddress（IP地址的代表类）常用方法：

| 名                                                 | 说明                                             |
| -------------------------------------------------- | ------------------------------------------------ |
| public static InetAddress getLocalHost（）         | 获取本机IP                                       |
| public static InetAddress getByName（String host） | 根据ip地址或域名，返回InetAddress对象            |
| public String getHostName（）                      | 获取该ip地址对象对应的主机名                     |
| public String getHostAddress（）                   | 获取该IP地址对象中的IP地址信息                   |
| public boolean isReachable（int timeout）          | 在指定毫秒内，判断主机与该ip地址的主机是否能连通 |

##### 9.1.2、端口号

应用程序在设备中唯一的标识，规定为16位的二进制，范围是0~65535

- 周知端口：0~1023，被预先定义的知名应用占用（HTTP占用80，FTP占用21）
- 注册端口：1024~49151，分配给用户进程或某些应用程序
- 动态端口：49152~65535，一般不固定分配某种进程，而是动态分配

注意：我们自己开发的程序一般选择使用**注册端口**，且一个设备中不能出现两个程序的端口号一样，否则出
错。

##### 9.1.3、协议

连接和数据在网络中传输的规则

为了让全球所有的上网设备都能互联

* OSI网络参考模型：开放式网络互联标准；全球网络互联标准

* TCP/IP网络模型：事实上的国际标准

  ![image-20231015165702855](https://gitee.com/coi4/test/raw/master/img/image-20231015165702855.png)

传输层2个通信协议：

* UDP协议（User Datagram protocal） ：
  * 无连接、不可靠通信、通信效率高（语音通话、视频直播）、一次最多发64k、数据不安全、容易丢失
  * 不是先建立连接，数据按照包发，一包数据包含：自己的ip、程序端口、目的地 IP 、程序端口和数据（限制在 64KB 内）等
  * 发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的
* TCP协议：
  * 面向连接、可靠通信、通信效率相对不高（网页、文件下载、支付）、连接中可进行大数据量的传输
  * 最终目的：保证在不可靠的信道上实现可靠的传输
  * 主要有三个步骤实现可靠传输：
    * 三次握手建立连接---确定通信双方收发消息正常（全双工）![image-20231015170635087](https://gitee.com/coi4/test/raw/master/img/image-20231015170635087.png)
    * 传输数据进行确认
    * 四次挥手断开连接---确保双方数据的收发都已经完成![image-20231015170741357](https://gitee.com/coi4/test/raw/master/img/image-20231015170741357.png)

#### 9.2、UDP通信快速入门

Java.net.DatagramSocket类实现

**DatagramSocket**：用于创建客户端、服务端

构造器：

| 构造器                              | 说明                                             |
| ----------------------------------- | ------------------------------------------------ |
| public DatagramSocket（）           | 创建客户端的Socket对象，系统会随机分配一个端口号 |
| public DatagramSocket（int   port） | 创建服务端的Socket对象，并指定端口号             |

方法：

| 名                                      | 说明               |
| --------------------------------------- | ------------------ |
| public void send（DatagramPacket dp）   | 发送数据包         |
| public void receive（DatagramPacket p） | 使用数据包接收数据 |

**DatagramPacket**：创建数据包

构造器：

| 构造器                                                       | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| public DatagramPacket（byte[] buf, int length,  InetAddress address,int port) | 创建发出去的数据包对象   |
| public DatagramPacket(byte[] buf,int length)                 | 创建用来接收数据的数据包 |

 方法：

| 名                       | 说明                             |
| ------------------------ | -------------------------------- |
| public int getLength（） | 获取数据包，实际接收到的字节个数 |

##### 9.2.1、案例

> 使用 UDP 通信实现：发送消息、接收消息

```
客户端：
① 创建 DatagramSocket 对象（客户端对象） 
② 创建 DatagramPacket 对象封装需要发送的数据（数据包对象） 
③ 使用 DatagramSocket 对象的 send 方法，传入 DatagramPacket 对象
④ 释放资源

服务端：
① 创建 DatagramSocket 对象并指定端口（服务端对象） 
② 创建 DatagramPacket 对象接收数据（数据包对象） 
③ 使用 DatagramSocket 对象的 receive 方法，传入 DatagramPacket 对象
④ 释放资源
```

#### 9.3、UDP通信多发多收

##### 9.3.1、案例

> 客户端可以反复发送数据

```
客户端实现步骤：
① 创建 DatagramSocket 对象（发送端对象） 
② 使用 while 死循环不断的接收用户的数据输入，如果用户输入的 exit 则退出程序
③ 如果用户输入的不是 exit, 把数据封装成 DatagramPacket 
④ 使用 DatagramSocket 对象的 send 方法将数据包对象进行发送 
⑤ 释放资源

接收端实现步骤：
① 创建 DatagramSocket 对象并指定端口（接收端对象） 
② 创建 DatagramPacket 对象接收数据（数据包对象） 
③ 使用 DatagramSocket 对象的 receive 方法传入 DatagramPacket 对象
④ 使用 while 死循环不断的进行第 3 步
```

#### 9.4、TCP通信快速入门

客户端开发：

Java.net.Socket类实现

| 构造器                                 | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| public Socket（String host，int port） | 根据指定的服务器ip、端口号请求与服务器建立连接，连接通过，就获得了客户端 socket |

| 方法名                                  | 说明               |
| --------------------------------------- | ------------------ |
| public OutputStream getOutputStream（） | 获得字节输出流对象 |
| public InputStream getInputStream（）   | 获得字节输入流对象 |

##### 9.4.1、客户端实操

> 客户端发送消息

```
① 创建客户端的 Socket 对象，请求与服务端的连接。
② 使用 socket 对象调用 getOutputStream() 方法得到字节输出流。
③ 使用字节输出流完成数据的发送。
④ 释放资源：关闭 socket 管道。
```

服务端程序的开发：

java.net.ServerSocket类实现

| 构造器                          | 说明             |
| ------------------------------- | ---------------- |
| public ServerSocket（int port） | 为服务端注册端口 |

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| public Socket accept（） | 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的 Socket 对象 |

##### 9.4.2、服务端案例

> 服务端实现接收消息

```
① 创建 ServerSocket 对象，注册服务端端口。
② 调用 ServerSocket 对象的 accept() 方法，等待客户端的连接，并得到 Socket 管道对象。
③ 通过 Socket 对象调用 getInputStream() 方法得到字节输入流、完成数据的接收。
④ 释放资源：关闭 socket 管道
```

#### 9.5、TCP通信多发多收

##### 9.5.1、实操

> 使用TCP通信实现多发多收消息

```
①客户端使用死循环，让用户不断输入消息。
②服务端也使用死循环，控制服务端收完消息，继续等待接收下一个消息。
```

#### 9.6、TCP通信同时接收多个客户端

* 主线程定义了循环负责接收客户端 Socket 管道连接
* 每接收到一个 Socket 通信管道后分配一个独立的线程负责处理
  它。

#### 9.7、TCP通信案例

> 即时通信-群聊

```

```

> 实现一个简易版的BS架构
>
> 要求从浏览器中访问服务器
> 并立即让服务器响应一个很简单的网页给浏览器
> 展示
> 网页内容就是“黑马程序员 666”

```

```

### 10、Java高级

